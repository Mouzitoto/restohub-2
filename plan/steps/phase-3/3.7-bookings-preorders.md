# Шаг 3.7: Бронирования и предзаказы

## Описание
Реализация API для просмотра и управления бронированиями и предзаказами в админке, подтверждение через WhatsApp бот.

## Задачи

### 1. API для просмотра бронирований

#### 1.1. GET `/admin-api/r/:id/booking` - список бронирований ресторана
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана

**Query параметры:**
- `limit` - integer (optional, default: 50, min: 1, max: 100) - количество результатов
- `offset` - integer (optional, default: 0, min: 0) - смещение для пагинации
- `statusCode` - string (optional) - фильтр по коду статуса: "DRAFT", "PENDING", "APPROVED", "REJECTED", "CANCELLED"
- `dateFrom` - date (optional, format: YYYY-MM-DD) - фильтр по дате начала (бронирования с `booking_date >= dateFrom`)
- `dateTo` - date (optional, format: YYYY-MM-DD) - фильтр по дате окончания (бронирования с `booking_date <= dateTo`)
- `tableId` - long (optional) - фильтр по столу
- `clientPhone` - string (optional) - поиск по номеру телефона клиента через JOIN с clients (LIKE)
- `sortBy` - string (optional, default: "bookingDate") - поле для сортировки: "bookingDate", "createdAt", "statusCode" (сортировка по коду статуса через JOIN с booking_statuses)
- `sortOrder` - string (optional, default: "desc") - порядок сортировки: "asc" или "desc"

**Response 200 OK:**
```json
{
  "data": [
    {
      "id": 1,
      "restaurantId": 1,
      "tableId": 1,
      "tableNumber": "1",
      "bookingDate": "2024-01-15",
      "bookingTime": "19:00:00",
      "personCount": 4,
      "clientName": "Иван Иванов", // на чье имя забронировали
      "specialRequests": "У окна",
      "status": {
        "code": "APPROVED",
        "name": "Одобрено"
      },
      "createdAt": "2024-01-01T09:00:00Z",
      "updatedAt": "2024-01-01T11:00:00Z"
    }
  ],
  "pagination": {
    "total": 100,
    "limit": 50,
    "offset": 0,
    "hasMore": true
  }
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск ресторана по ID с `is_active = true`
3. Построение запроса: `SELECT b.*, t.table_number FROM bookings b JOIN tables t ON b.table_id = t.id JOIN rooms r ON t.room_id = r.id JOIN floors f ON r.floor_id = f.id WHERE f.restaurant_id = :id`
4. Применение фильтров:
   - По статусу: `AND b.booking_status_id = (SELECT id FROM booking_statuses WHERE code = :statusCode)` (если указано `statusCode`)
   - По дате: `AND b.booking_date >= :dateFrom AND b.booking_date <= :dateTo` (если указано)
   - По столу: `AND b.table_id = :tableId` (если указано)
   - По телефону: `AND EXISTS (SELECT 1 FROM clients c WHERE c.id = b.client_id AND c.phone ILIKE '%:clientPhone%')` (если указано)
5. Применение сортировки
6. Применение пагинации
7. Подсчет общего количества записей
8. Возврат списка с пагинацией

**Ошибки:**
- 400 Bad Request: невалидные query параметры
- 404 Not Found: ресторан не найден или неактивен
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 1.2. GET `/admin-api/r/:id/booking/:bookingId` - получение бронирования
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `bookingId` - long (required) - ID бронирования

**Response 200 OK:**
```json
{
  "id": 1,
  "restaurantId": 1,
  "tableId": 1,
  "table": {
    "id": 1,
    "tableNumber": "1",
    "capacity": 4,
    "room": {
      "id": 1,
      "name": "Зал 1",
      "floor": {
        "id": 1,
        "floorNumber": 1
      }
    }
  },
  "bookingDate": "2024-01-15",
  "bookingTime": "19:00:00",
  "personCount": 4,
  "clientName": "Иван Иванов",
  "clientId": 1,
  "specialRequests": "У окна",
  "status": {
    "id": 3,
    "code": "APPROVED",
    "name": "Одобрено"
  },
  "history": [
    {
      "id": 1,
      "status": {
        "id": 1,
        "code": "PENDING",
        "name": "Ожидает подтверждения"
      },
      "changedAt": "2024-01-01T09:00:00Z",
      "changedBy": null,
      "comment": null
    },
    {
      "id": 2,
      "status": {
        "id": 3,
        "code": "APPROVED",
        "name": "Одобрено"
      },
      "changedAt": "2024-01-01T11:00:00Z",
      "changedBy": {
        "id": 5,
        "email": "manager@example.com"
      },
      "comment": null
    }
  ],
  "createdAt": "2024-01-01T09:00:00Z",
  "updatedAt": "2024-01-01T11:00:00Z"
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск бронирования: `SELECT b.* FROM bookings b JOIN tables t ON b.table_id = t.id JOIN rooms r ON t.room_id = r.id JOIN floors f ON r.floor_id = f.id WHERE b.id = :bookingId AND f.restaurant_id = :id`
3. Загрузка связанных данных (стол, помещение, этаж, статус)
4. Загрузка истории изменений: `SELECT bh.*, bs.code, bs.name, u.id as user_id, u.email FROM booking_history bh JOIN booking_statuses bs ON bh.booking_status_id = bs.id LEFT JOIN users u ON bh.changed_by = u.id WHERE bh.booking_id = :bookingId ORDER BY bh.changed_at ASC`
5. Возврат полной информации о бронировании с историей

**Ошибки:**
- 404 Not Found: бронирование не найдено или не принадлежит ресторану
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

### 2. API для просмотра предзаказов

#### 2.1. GET `/admin-api/r/:id/pre-order` - список предзаказов ресторана
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана

**Query параметры:**
- `limit` - integer (optional, default: 50, min: 1, max: 100)
- `offset` - integer (optional, default: 0, min: 0)
- `statusCode` - string (optional) - фильтр по коду статуса: "DRAFT", "PENDING", "APPROVED", "REJECTED", "CANCELLED"
- `dateFrom` - date (optional, format: YYYY-MM-DD) - фильтр по дате начала
- `dateTo` - date (optional, format: YYYY-MM-DD) - фильтр по дате окончания
- `bookingId` - long (optional) - фильтр по привязанному бронированию
- `clientPhone` - string (optional) - поиск по номеру телефона клиента через JOIN с clients (LIKE)
- `sortBy` - string (optional, default: "date") - поле для сортировки: "date", "totalAmount", "createdAt", "statusCode" (сортировка по коду статуса через JOIN с booking_statuses)
- `sortOrder` - string (optional, default: "desc") - порядок сортировки: "asc" или "desc"

**Response 200 OK:**
```json
{
  "data": [
    {
      "id": 1,
      "restaurantId": 1,
      "bookingId": 1,
      "date": "2024-01-15",
      "time": "19:00:00",
      "clientName": "Иван Иванов", // на чье имя забронировали
      "totalAmount": 3500.00,
      "specialRequests": "Без лука",
      "status": {
        "code": "APPROVED",
        "name": "Одобрено"
      },
      "itemsCount": 3,
      "createdAt": "2024-01-01T09:00:00Z",
      "updatedAt": "2024-01-01T11:00:00Z"
    }
  ],
  "pagination": {
    "total": 50,
    "limit": 50,
    "offset": 0,
    "hasMore": false
  }
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск ресторана по ID с `is_active = true`
3. Построение запроса: `SELECT po.* FROM pre_orders po WHERE po.restaurant_id = :id`
4. Применение фильтров:
   - По статусу: `AND po.booking_status_id = (SELECT id FROM booking_statuses WHERE code = :statusCode)` (если указано `statusCode`)
   - По датам, бронированию, телефону (аналогично бронированиям)
5. Применение сортировки
6. Применение пагинации
7. Подсчет количества позиций для каждого предзаказа: `SELECT COUNT(*) FROM pre_order_items WHERE pre_order_id = :preOrderId`
8. Возврат списка с пагинацией

**Ошибки:**
- 400 Bad Request: невалидные query параметры
- 404 Not Found: ресторан не найден или неактивен
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 2.2. GET `/admin-api/r/:id/pre-order/:preOrderId` - получение предзаказа
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `preOrderId` - long (required) - ID предзаказа

**Response 200 OK:**
```json
{
  "id": 1,
  "restaurantId": 1,
  "bookingId": 1,
  "booking": {
    "id": 1,
    "bookingDate": "2024-01-15",
    "bookingTime": "19:00:00",
    "tableNumber": "1"
  },
  "date": "2024-01-15",
  "time": "19:00:00",
  "clientId": 1,
  "clientName": "Иван Иванов", // на чье имя предзаказ
  "totalAmount": 3500.00,
  "specialRequests": "Без лука",
  "status": {
    "id": 3,
    "code": "APPROVED",
    "name": "Одобрено"
  },
  "history": [
    {
      "id": 1,
      "status": {
        "id": 1,
        "code": "PENDING",
        "name": "Ожидает подтверждения"
      },
      "changedAt": "2024-01-01T09:00:00Z",
      "changedBy": null,
      "comment": null
    },
    {
      "id": 2,
      "status": {
        "id": 3,
        "code": "APPROVED",
        "name": "Одобрено"
      },
      "changedAt": "2024-01-01T11:00:00Z",
      "changedBy": {
        "id": 5,
        "email": "manager@example.com"
      },
      "comment": null
    }
  ],
  "items": [
    {
      "id": 1,
      "menuItemId": 1,
      "menuItem": {
        "id": 1,
        "name": "Пицца Маргарита",
        "price": 1000.00
      },
      "quantity": 2,
      "price": 1000.00,
      "totalPrice": 2000.00,
      "specialRequests": "Без лука"
    },
    {
      "id": 2,
      "menuItemId": 2,
      "menuItem": {
        "id": 2,
        "name": "Салат Цезарь",
        "price": 500.00
      },
      "quantity": 3,
      "price": 500.00,
      "totalPrice": 1500.00,
      "specialRequests": null
    }
  ],
  "createdAt": "2024-01-01T09:00:00Z",
  "updatedAt": "2024-01-01T11:00:00Z"
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск предзаказа: `SELECT * FROM pre_orders WHERE id = :preOrderId AND restaurant_id = :id`
3. Загрузка позиций: `SELECT poi.*, mi.name FROM pre_order_items poi JOIN menu_items mi ON poi.menu_item_id = mi.id WHERE poi.pre_order_id = :preOrderId`
4. Загрузка связанного бронирования (если есть `booking_id`)
5. Загрузка истории изменений: `SELECT poh.*, bs.code, bs.name, u.id as user_id, u.email FROM pre_order_history poh JOIN booking_statuses bs ON poh.booking_status_id = bs.id LEFT JOIN users u ON poh.changed_by = u.id WHERE poh.pre_order_id = :preOrderId ORDER BY poh.changed_at ASC`
6. Возврат полной информации о предзаказе с позициями и историей

**Ошибки:**
- 404 Not Found: предзаказ не найден или не принадлежит ресторану
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

### 3. API для подтверждения бронирования/предзаказа менеджером

#### 3.1. POST `/admin-api/booking/:id/status` - изменение статуса бронирования
**Доступ:** Публичный (вызывается WhatsApp ботом, без аутентификации или с API ключом)

**Path параметры:**
- `id` - long (required) - ID бронирования

**Request Body:**
```json
{
  "status": "string (required, 'APPROVED' или 'REJECTED')",
  "managerId": "long (required, ID менеджера из users)"
}
```

**Response 200 OK:**
```json
{
  "success": true,
  "bookingId": 1,
  "status": {
    "code": "APPROVED",
    "name": "Одобрено"
  },
  "whatsappNotificationSent": true
}
```

**Логика:**
1. Поиск бронирования: `SELECT * FROM bookings WHERE id = :id AND booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'PENDING')`
2. Валидация статуса (только 'APPROVED' или 'REJECTED')
3. Проверка существования менеджера: `SELECT * FROM users WHERE id = :managerId AND role_id = (SELECT id FROM roles WHERE code = 'MANAGER')`
4. Проверка принадлежности менеджера к ресторану: `SELECT * FROM users_2_restaurants WHERE user_id = :managerId AND restaurant_id = :restaurantId`
5. Обновление бронирования:
   - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = :status)`
   - `updated_at = NOW()`
6. Запись в историю изменений:
   - Создать запись в `booking_history`:
     - `booking_id = :id`
     - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = :status)`
     - `changed_at = NOW()`
     - `changed_by = :managerId`
     - `comment = NULL`
7. Если статус 'APPROVED':
   - Отправка уведомления клиенту через WhatsApp бот:
     - Получить номер телефона клиента из бронирования
     - Сформировать сообщение с подтверждением бронирования
     - Отправить через WhatsApp бот API
8. Возврат результата

**Ошибки:**
- 400 Bad Request: невалидные данные, бронирование не найдено, неверный статус
- 404 Not Found: бронирование не найдено
- 403 Forbidden: менеджер не имеет доступа к ресторану этого бронирования
- 500 Internal Server Error: ошибка при отправке WhatsApp уведомления

#### 3.2. POST `/admin-api/pre-order/:id/status` - изменение статуса предзаказа
**Доступ:** Публичный (вызывается WhatsApp ботом, без аутентификации или с API ключом)

**Path параметры:**
- `id` - long (required) - ID предзаказа

**Request Body:**
```json
{
  "status": "string (required, 'APPROVED' или 'REJECTED')",
  "managerId": "long (required, ID менеджера из users)"
}
```

**Response 200 OK:**
```json
{
  "success": true,
  "preOrderId": 1,
  "status": {
    "code": "APPROVED",
    "name": "Одобрено"
  },
  "whatsappNotificationSent": true
}
```

**Логика:**
1. Поиск предзаказа: `SELECT * FROM pre_orders WHERE id = :id AND booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'PENDING')`
2. Валидация статуса
3. Проверка существования и доступа менеджера
4. Обновление предзаказа:
   - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = :status)`
   - `updated_at = NOW()`
5. Запись в историю изменений:
   - Создать запись в `pre_order_history`:
     - `pre_order_id = :id`
     - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = :status)`
     - `changed_at = NOW()`
     - `changed_by = :managerId`
     - `comment = NULL`
6. Если статус 'APPROVED':
   - Отправка уведомления клиенту через WhatsApp бот с информацией о подтверждении предзаказа
7. Возврат результата

**Ошибки:**
- 400 Bad Request: невалидные данные, предзаказ не найден, неверный статус
- 404 Not Found: предзаказ не найден
- 403 Forbidden: менеджер не имеет доступа к ресторану этого предзаказа
- 500 Internal Server Error: ошибка при отправке WhatsApp уведомления

### 4. API для отмены бронирования/предзаказа

#### 4.1. PUT `/admin-api/r/:id/booking/:bookingId/cancel` - отмена бронирования
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `bookingId` - long (required) - ID бронирования

**Response 200 OK:**
```json
{
  "id": 1,
  "status": {
    "code": "CANCELLED",
    "name": "Отменено"
  },
  "cancelledAt": "2024-01-01T12:00:00Z"
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск бронирования с проверкой принадлежности к ресторану
3. Проверка текущего статуса:
   - Можно отменить только бронирования со статусами: 'PENDING', 'APPROVED'
   - Нельзя отменить уже отмененные ('CANCELLED') или отклоненные ('REJECTED')
4. Обновление бронирования:
   - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'CANCELLED')`
   - `updated_at = NOW()`
5. Запись в историю изменений:
   - Создать запись в `booking_history`:
     - `booking_id = :bookingId`
     - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'CANCELLED')`
     - `changed_at = NOW()`
     - `changed_by = :userId` (ID текущего пользователя из контекста, NULL если отменено клиентом)
     - `comment = NULL`
6. Уведомление клиента (опционально):
   - Получить номер телефона клиента через `client_id`: `SELECT phone FROM clients WHERE id = :clientId`
   - Если номер найден, отправить уведомление через WhatsApp бот
7. Возврат обновленного бронирования

**Ошибки:**
- 400 Bad Request: бронирование уже отменено или отклонено
- 404 Not Found: бронирование не найдено или не принадлежит ресторану
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 4.2. PUT `/admin-api/r/:id/pre-order/:preOrderId/cancel` - отмена предзаказа
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `preOrderId` - long (required) - ID предзаказа

**Response 200 OK:**
```json
{
  "id": 1,
  "status": {
    "code": "CANCELLED",
    "name": "Отменено"
  },
  "cancelledAt": "2024-01-01T12:00:00Z"
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск предзаказа с проверкой принадлежности к ресторану
3. Проверка текущего статуса (аналогично бронированию)
4. Обновление предзаказа:
   - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'CANCELLED')`
   - `updated_at = NOW()`
5. Запись в историю изменений:
   - Создать запись в `pre_order_history`:
     - `pre_order_id = :preOrderId`
     - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'CANCELLED')`
     - `changed_at = NOW()`
     - `changed_by = :userId` (ID текущего пользователя из контекста, NULL если отменено клиентом)
     - `comment = NULL`
6. Уведомление клиента (опционально)
7. Возврат обновленного предзаказа

**Ошибки:**
- 400 Bad Request: предзаказ уже отменен или отклонен
- 404 Not Found: предзаказ не найден или не принадлежит ресторану
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

### 5. Валидация и бизнес-логика

#### 5.1. Валидация номеров телефонов
- Формат: `+7XXXXXXXXXX` или `8XXXXXXXXXX` (10 цифр после +7 или 8)
- Нормализация к формату `+7XXXXXXXXXX` при сохранении
- Кастомный валидатор: `@Phone` (см. шаг 3.1)

#### 5.2. Проверка существования бронирования/предзаказа
- При изменении статуса: проверка статуса 'PENDING'
- При отмене: проверка статусов 'PENDING', 'APPROVED'

#### 5.3. История изменений статусов
- При каждом изменении статуса создается запись в `booking_history` или `pre_order_history`
- История загружается при получении детальной информации о бронировании/предзаказе
- Структура записи истории:
  - `id` - ID записи истории
  - `status` - объект с `id`, `code`, `name` (статус на момент изменения)
  - `changedAt` - дата и время изменения
  - `changedBy` - объект с информацией о пользователе (null если изменил клиент или бот): `id`, `email`
  - `comment` - комментарий к изменению (опционально)
- История сортируется по `changed_at ASC` (от старых к новым)

#### 5.4. Проверка принадлежности к ресторану
- Для бронирования: через JOIN `tables → rooms → floors → restaurants`
- Для предзаказа: через `pre_orders.restaurant_id`
- Проверка выполняется во всех операциях получения/обновления

#### 5.5. Проверка прав доступа менеджера
- При изменении статуса через WhatsApp бот:
  - Проверка существования менеджера
  - Проверка принадлежности менеджера к ресторану через `users_2_restaurants`
  - Если менеджер не имеет доступа → вернуть ошибку 403

#### 5.6. Логика работы с клиентами
- Клиент создается/обновляется при создании бронирования/предзаказа через WhatsApp бот
- WhatsApp бот передает номер телефона и "свое имя" клиента
- Если клиент существует:
  - Обновляется `first_name` (если указано новое имя)
  - Обновляется `last_booking_date` (при бронировании)
  - Увеличивается `total_bookings` (при бронировании) или `total_pre_orders` (при предзаказе)
- Если клиент не существует:
  - Создается новый клиент с `phone` и `first_name`
  - Устанавливается `first_booking_date` (если это первое бронирование)
  - Устанавливается `total_bookings = 1` (при бронировании) или `total_pre_orders = 1` (при предзаказе)
- Связывание бронирований/предзаказов с клиентом через обязательное поле `client_id`
- "На чье имя бронировать/предзаказ" сохраняется в `bookings.client_name` / `pre_orders.client_name` (может отличаться от `clients.first_name`)

#### 5.7. Интеграция с WhatsApp ботом
- API для отправки уведомлений менеджерам:
  - Вызов WhatsApp бота (настраивается через конфигурацию)
  - Формат уведомления: текст с информацией о бронировании/предзаказе + интерактивные кнопки
  - Использование языка из `restaurants.manager_language_code` для формирования текста
  - Кнопки: "Подтвердить", "Отказать" и "Связаться с клиентом" с callback данными (booking_id/pre_order_id, action)
- Обработка callback от WhatsApp бота:
  - Получение данных из callback (booking_id/pre_order_id, action)
  - Вызов соответствующего endpoint для изменения статуса или генерации ссылки на клиента
- API для отправки уведомлений клиентам:
  - Вызов WhatsApp бота (настраивается через конфигурацию)
  - Формат сообщения: текст с подтверждением/отклонением бронирования/предзаказа
  - Отправка на номер телефона клиента: получение через `client_id` из `clients.phone`

## Результаты выполнения шага

По итогу выполнения этого шага должны быть созданы следующие артефакты и выполнены следующие проверки:

### Созданные компоненты:
1. ✅ Booking Controller:
   - `GET /admin-api/r/:id/booking` endpoint
   - `GET /admin-api/r/:id/booking/:bookingId` endpoint
   - `PUT /admin-api/r/:id/booking/:bookingId/cancel` endpoint

2. ✅ PreOrder Controller:
   - `GET /admin-api/r/:id/pre-order` endpoint
   - `GET /admin-api/r/:id/pre-order/:preOrderId` endpoint
   - `PUT /admin-api/r/:id/pre-order/:preOrderId/cancel` endpoint

3. ✅ Booking/PreOrder Service:
   - Методы для получения списков с фильтрацией
   - Методы для создания бронирований/предзаказов (вызываются WhatsApp ботом)
   - Методы для подтверждения через WhatsApp бот
   - Методы для отмены
   - Методы для записи в историю изменений статусов
   - Методы для загрузки истории изменений

### Функциональные проверки:
1. ✅ Просмотр бронирований работает:
   - Получение списка бронирований с фильтрацией
   - Получение бронирования по ID с историей изменений статусов

2. ✅ Просмотр предзаказов работает:
   - Получение списка предзаказов с фильтрацией
   - Получение предзаказа по ID с историей изменений статусов

3. ✅ Создание бронирования/предзаказа работает:
   - Бронирование/предзаказ создается с обязательным client_id
   - Клиент создается/обновляется в БД при создании
   - "Свое имя" сохраняется в clients.first_name
   - "На чье имя бронировать/предзаказ" сохраняется в bookings.client_name / pre_orders.client_name
   - WhatsApp бот получает уведомление и отправляет его менеджеру

4. ✅ Подтверждение через WhatsApp бот работает:
   - Статус обновляется на APPROVED/REJECTED
   - Запись создается в истории изменений
   - Ответ отправляется клиенту через WhatsApp

5. ✅ История изменений работает:
   - При создании бронирования/предзаказа создается запись в истории (PENDING)
   - При каждом изменении статуса создается новая запись в истории
   - История загружается при получении детальной информации
   - История сортируется по дате изменения (от старых к новым)

6. ✅ Отмена работает:
   - Статус обновляется на CANCELLED
   - Запись создается в истории изменений
   - Уведомление клиента (если реализовано)

### Критерии готовности:
- ✅ Все endpoints работают
- ✅ Проверка доступа через интерцептор работает
- ✅ Фильтрация работает корректно
- ✅ История изменений статусов записывается при каждом изменении
- ✅ История загружается и отображается в детальных ответах
- ✅ Интеграция с WhatsApp ботом работает
- ✅ Все функциональные проверки пройдены успешно

**Шаг считается выполненным**, когда все endpoints работают и все функциональные проверки пройдены успешно.


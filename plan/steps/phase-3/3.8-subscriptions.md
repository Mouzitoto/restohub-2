# Шаг 3.8: Подписки

## Описание
Реализация системы подписок: хранение информации о подписке ресторана, статус активности.

## Задачи

### 1. API для работы с подписками

#### 1.1. GET `/admin-api/r/:id/subscription` - получение информации о подписке
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана

**Response 200 OK:**
```json
{
  "id": 1,
  "restaurantId": 1,
  "subscriptionType": {
    "id": 1,
    "code": "PREMIUM",
    "name": "Премиум",
    "description": "Полный доступ ко всем функциям",
    "price": 5000.00
  },
  "startDate": "2024-01-01",
  "endDate": "2024-01-31",
  "isActive": true,
  "description": null,
  "daysRemaining": 15,
  "isExpiringSoon": false,
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-01T00:00:00Z"
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск ресторана по ID с `is_active = true`
3. Поиск активной подписки: `SELECT rs.*, st.* FROM restaurant_subscriptions rs JOIN subscription_types st ON rs.subscription_type_id = st.id WHERE rs.restaurant_id = :id AND rs.is_active = true ORDER BY rs.end_date DESC LIMIT 1`
4. Если подписка найдена:
   - Расчет `daysRemaining = end_date - CURRENT_DATE`
   - Расчет `isExpiringSoon = daysRemaining <= 7` (предупреждение за 7 дней)
5. Если подписка не найдена:
   - Вернуть ответ с `isActive = false` и сообщением об отсутствии активной подписки
6. Возврат информации о подписке

**Ошибки:**
- 404 Not Found: ресторан не найден или неактивен
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 1.2. PUT `/admin-api/r/:id/subscription` - обновление подписки
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Path параметры:**
- `id` - long (required) - ID ресторана

**Request Body:**
```json
{
  "subscriptionTypeId": "long (optional, должен существовать в subscription_types)",
  "startDate": "date (optional, format: YYYY-MM-DD)",
  "endDate": "date (optional, format: YYYY-MM-DD)",
  "isActive": "boolean (optional)",
  "description": "string (optional, TEXT, max 10000)"
}
```

**Response 200 OK:**
```json
{
  "id": 1,
  "restaurantId": 1,
  "subscriptionType": {
    "id": 1,
    "code": "PREMIUM",
    "name": "Премиум"
  },
  "startDate": "2024-01-01",
  "endDate": "2024-02-29",
  "isActive": true,
  "description": "Продление подписки",
  "daysRemaining": 45,
  "isExpiringSoon": false,
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-15T00:00:00Z"
}
```

**Логика:**
1. Проверка доступа: только ADMIN
2. Поиск ресторана по ID с `is_active = true`
3. Поиск текущей подписки (активной или последней)
4. Валидация всех переданных полей:
   - Если указан `subscriptionTypeId` - проверка существования и активности типа подписки
   - Если указаны даты - проверка, что `endDate >= startDate`
   - Если указан `endDate` - проверка, что дата не в прошлом (или разрешить для продления)
5. Обновление подписки:
   - Если подписка существует - обновить переданные поля
   - Если подписка не существует - создать новую подписку
6. Установка `updated_at = NOW()`
7. Расчет `daysRemaining` и `isExpiringSoon`
8. Возврат обновленной подписки

**Ошибки:**
- 400 Bad Request: невалидные данные, тип подписки не найден, неверные даты
- 404 Not Found: ресторан не найден или неактивен
- 403 Forbidden: пользователь не ADMIN

#### 1.3. GET `/admin-api/subscription` - список всех подписок (только для ADMIN)
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Query параметры:**
- `limit` - integer (optional, default: 50, min: 1, max: 100)
- `offset` - integer (optional, default: 0, min: 0)
- `isActive` - boolean (optional) - фильтр по активности
- `restaurantId` - long (optional) - фильтр по ресторану
- `subscriptionTypeId` - long (optional) - фильтр по типу подписки
- `expiringSoon` - boolean (optional) - фильтр по подпискам, истекающим в течение 7 дней
- `sortBy` - string (optional, default: "endDate") - поле для сортировки: "endDate", "startDate", "createdAt"
- `sortOrder` - string (optional, default: "asc") - порядок сортировки: "asc" или "desc"

**Response 200 OK:**
```json
{
  "data": [
    {
      "id": 1,
      "restaurantId": 1,
      "restaurantName": "Ресторан 1",
      "subscriptionType": {
        "id": 1,
        "code": "PREMIUM",
        "name": "Премиум"
      },
      "startDate": "2024-01-01",
      "endDate": "2024-01-31",
      "isActive": true,
      "daysRemaining": 15,
      "isExpiringSoon": false
    }
  ],
  "pagination": {
    "total": 100,
    "limit": 50,
    "offset": 0,
    "hasMore": true
  }
}
```

**Логика:**
1. Проверка доступа: только ADMIN
2. Построение запроса: `SELECT rs.*, r.name as restaurant_name, st.* FROM restaurant_subscriptions rs JOIN restaurants r ON rs.restaurant_id = r.id JOIN subscription_types st ON rs.subscription_type_id = st.id WHERE 1=1`
3. Применение фильтров:
   - По активности: `AND rs.is_active = :isActive` (если указано)
   - По ресторану: `AND rs.restaurant_id = :restaurantId` (если указано)
   - По типу: `AND rs.subscription_type_id = :subscriptionTypeId` (если указано)
   - По истекающим: `AND rs.end_date <= CURRENT_DATE + INTERVAL '7 days' AND rs.is_active = true` (если `expiringSoon = true`)
4. Применение сортировки
5. Применение пагинации
6. Расчет `daysRemaining` и `isExpiringSoon` для каждой подписки
7. Возврат списка с пагинацией

**Ошибки:**
- 400 Bad Request: невалидные query параметры
- 403 Forbidden: пользователь не ADMIN

### 2. Валидация полей подписки

#### 2.1. Правила валидации

**subscriptionTypeId** (ID типа подписки):
- Опциональное поле при обновлении
- Тип: BIGINT
- Кастомная валидация:
  - Должно существовать в таблице `subscription_types`
  - Тип подписки должен быть активным (`is_active = true`)
  - Кастомный валидатор: `@ValidSubscriptionTypeId`

**startDate** (дата начала):
- Опциональное поле при обновлении
- Тип: DATE
- Формат: YYYY-MM-DD
- Валидатор: `@PastOrPresent` (дата не должна быть в будущем при создании, или разрешить для продления)

**endDate** (дата окончания):
- Опциональное поле при обновлении
- Тип: DATE
- Формат: YYYY-MM-DD
- Валидация: `endDate >= startDate` (если указаны обе даты)
- Валидатор: `@Future` (дата должна быть в будущем)

**isActive** (статус активности):
- Опциональное поле при обновлении
- Тип: BOOLEAN
- Только ADMIN может изменять

**description** (описание):
- Опциональное поле
- Тип: TEXT
- Максимальная длина на уровне валидации: 10000 символов (`@Size(max = 10000)`)

#### 2.2. Кастомные валидаторы

**@ValidSubscriptionTypeId** - валидация существования и активности типа подписки:
```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ValidSubscriptionTypeIdValidator.class)
public @interface ValidSubscriptionTypeId {
    String message() default "Subscription type not found or inactive";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```
- Проверка через `SubscriptionTypeRepository.findByIdAndIsActiveTrue(subscriptionTypeId)`

#### 2.3. Логика проверки существования связанных сущностей

**Проверка ресторана:**
1. При получении/обновлении подписки:
   - Выполнить запрос: `SELECT * FROM restaurants WHERE id = :restaurantId AND is_active = true`
   - Если ресторан не найден или неактивен → вернуть ошибку 404

**Проверка типа подписки:**
1. При обновлении подписки с `subscriptionTypeId`:
   - Выполнить запрос: `SELECT * FROM subscription_types WHERE id = :subscriptionTypeId AND is_active = true`
   - Если тип не найден или неактивен → вернуть ошибку 400

### 3. Проверка активности подписки

#### 3.1. Логика проверки
- Подписка считается активной, если:
  - `is_active = true`
  - `CURRENT_DATE >= start_date`
  - `CURRENT_DATE <= end_date`
- SQL запрос: `SELECT * FROM restaurant_subscriptions WHERE restaurant_id = :id AND is_active = true AND CURRENT_DATE >= start_date AND CURRENT_DATE <= end_date`

#### 3.2. Middleware/Interceptor для проверки
- Для client-api: проверка активной подписки перед возвратом публичных данных ресторана
- Для admin-api: проверка активной подписки при работе с данными ресторана (опционально, можно разрешить работу даже при неактивной подписке)
- Логика:
  1. Получить активную подписку для ресторана
  2. Если подписка не найдена или истекла → вернуть ошибку или предупреждение
  3. Если подписка активна → продолжить выполнение запроса

#### 3.3. Предупреждения о скором окончании
- Расчет `daysRemaining = end_date - CURRENT_DATE`
- Если `daysRemaining <= 7` → установить `isExpiringSoon = true`
- Возвращать флаг `isExpiringSoon` в ответах API для отображения предупреждений на фронтенде

### 4. Логика работы с подписками

#### 4.1. Создание подписки
- Создается автоматически при активации подписки ресторана
- Или создается вручную администратором через PUT запрос
- При создании устанавливается:
  - `restaurant_id = :id`
  - `subscription_type_id = :subscriptionTypeId`
  - `start_date = :startDate` (или CURRENT_DATE, если не указано)
  - `end_date = :endDate`
  - `is_active = true`
  - `created_at = NOW()`, `updated_at = NOW()`

#### 4.2. Продление подписки
- Администратор может продлить подписку через PUT запрос:
  - Обновить `end_date` на новую дату
  - Установить `is_active = true` (если была неактивна)
  - Установить `updated_at = NOW()`
- Логика продления:
  - Если текущая подписка активна → обновить `end_date`
  - Если текущая подписка неактивна → создать новую подписку или обновить существующую

#### 4.3. Деактивация подписки
- Администратор может деактивировать подписку:
  - Установить `is_active = false`
  - Указать `description` с причиной деактивации
  - Установить `updated_at = NOW()`
- Деактивированная подписка не блокирует работу ресторана в админке, но может блокировать публичный доступ (в client-api)

### 6. Оптимизация индексов
**Примечание**: После реализации фазы 3 необходимо проанализировать запросы к БД и создать/оптимизировать индексы.

- Анализ всех SQL запросов, выполненных в рамках фазы 3 (Admin API)
- Определение медленных запросов
- Создание индексов для:
  - Foreign keys (restaurants, menu_categories, menu_items, floors, rooms, tables, promotions)
  - Поля для фильтрации (`is_active`, `restaurant_id`)
  - Поля для поиска (если используется)
- Добавление индексов через миграции Liquibase
- Тестирование производительности запросов с новыми индексами


# Шаг 3.11: Клиенты

## Описание
Реализация API для просмотра информации о клиентах, истории бронирований и предзаказов.

## Задачи

### 1. API для просмотра клиентов

#### 1.1. GET `/admin-api/r/:id/client` - список клиентов ресторана
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана

**Query параметры:**
- `limit` - integer (optional, default: 50, min: 1, max: 100)
- `offset` - integer (optional, default: 0, min: 0)
- `search` - string (optional) - поиск по телефону или имени (LIKE)
- `sortBy` - string (optional, default: "lastBookingDate") - поле для сортировки: "lastBookingDate", "totalBookings", "totalPreOrders", "createdAt"
- `sortOrder` - string (optional, default: "desc") - порядок сортировки: "asc" или "desc"

**Response 200 OK:**
```json
{
  "data": [
    {
      "id": 1,
      "phone": "+79991234567",
      "firstName": "Иван",
      "firstBookingDate": "2024-01-01T00:00:00Z",
      "lastBookingDate": "2024-01-15T00:00:00Z",
      "totalBookings": 5,
      "totalPreOrders": 3,
      "createdAt": "2024-01-01T00:00:00Z"
    }
  ],
  "pagination": {
    "total": 200,
    "limit": 50,
    "offset": 0,
    "hasMore": true
  }
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск ресторана по ID с `is_active = true`
3. Построение запроса: `SELECT DISTINCT c.* FROM clients c WHERE EXISTS (SELECT 1 FROM bookings b JOIN tables t ON b.table_id = t.id JOIN rooms r ON t.room_id = r.id JOIN floors f ON r.floor_id = f.id WHERE b.client_id = c.id AND f.restaurant_id = :id) OR EXISTS (SELECT 1 FROM pre_orders po WHERE po.client_id = c.id AND po.restaurant_id = :id)`
4. Применение поиска:
   - По телефону: `AND c.phone ILIKE '%:search%'`
   - По имени: `AND c.first_name ILIKE '%:search%'`
5. Применение сортировки
6. Применение пагинации
7. Возврат списка с пагинацией

**Ошибки:**
- 400 Bad Request: невалидные query параметры
- 404 Not Found: ресторан не найден или неактивен
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 1.2. GET `/admin-api/r/:id/client/:clientId` - получение информации о клиенте
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `clientId` - long (required) - ID клиента

**Response 200 OK:**
```json
{
  "id": 1,
  "phone": "+79991234567",
  "firstName": "Иван",
  "firstBookingDate": "2024-01-01T00:00:00Z",
  "lastBookingDate": "2024-01-15T00:00:00Z",
  "totalBookings": 5,
  "totalPreOrders": 3,
  "totalSpent": 15000.00,
  "statistics": {
    "averageBookingPersons": 3.5,
    "averagePreOrderAmount": 3500.00,
    "favoriteTable": {
      "id": 1,
      "tableNumber": "1"
    },
    "favoriteMenuItem": {
      "id": 1,
      "name": "Пицца Маргарита"
    }
  },
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-15T00:00:00Z"
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск клиента: `SELECT * FROM clients WHERE id = :clientId`
3. Проверка принадлежности клиента к ресторану:
   - Проверка наличия бронирований или предзаказов клиента в этом ресторане
   - Если клиент не связан с рестораном → вернуть ошибку 404
4. Расчет статистики:
   - Среднее количество персон: `SELECT AVG(person_count) FROM bookings WHERE client_id = :clientId AND restaurant_id = :id`
   - Средний чек предзаказов: `SELECT AVG(total_amount) FROM pre_orders WHERE client_id = :clientId AND restaurant_id = :id`
   - Общая потраченная сумма: `SELECT SUM(total_amount) FROM pre_orders WHERE client_id = :clientId AND restaurant_id = :id`
   - Любимый стол: `SELECT table_id, COUNT(*) as count FROM bookings WHERE client_id = :clientId AND restaurant_id = :id GROUP BY table_id ORDER BY count DESC LIMIT 1`
   - Любимое блюдо: `SELECT poi.menu_item_id, COUNT(*) as count FROM pre_order_items poi JOIN pre_orders po ON poi.pre_order_id = po.id WHERE po.client_id = :clientId AND po.restaurant_id = :id GROUP BY poi.menu_item_id ORDER BY count DESC LIMIT 1`
5. Возврат полной информации о клиенте

**Ошибки:**
- 404 Not Found: клиент не найден или не связан с рестораном
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

### 2. API для истории бронирований клиента

#### 2.1. GET `/admin-api/r/:id/client/:clientId/booking` - история бронирований клиента
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `clientId` - long (required) - ID клиента

**Query параметры:**
- `limit` - integer (optional, default: 50, min: 1, max: 100)
- `offset` - integer (optional, default: 0, min: 0)
- `statusCode` - string (optional) - фильтр по коду статуса: "PENDING", "APPROVED", "REJECTED", "CANCELLED"
- `dateFrom` - date (optional, format: YYYY-MM-DD) - фильтр по дате начала
- `dateTo` - date (optional, format: YYYY-MM-DD) - фильтр по дате окончания
- `sortBy` - string (optional, default: "bookingDate") - поле для сортировки: "bookingDate", "createdAt"
- `sortOrder` - string (optional, default: "desc") - порядок сортировки: "asc" или "desc"

**Response 200 OK:**
```json
{
  "clientId": 1,
  "data": [
    {
      "id": 1,
      "tableId": 1,
      "tableNumber": "1",
      "bookingDate": "2024-01-15",
      "bookingTime": "19:00:00",
      "personCount": 4,
      "status": "APPROVED",
      "specialRequests": "У окна",
      "createdAt": "2024-01-01T09:00:00Z"
    }
  ],
  "pagination": {
    "total": 5,
    "limit": 50,
    "offset": 0,
    "hasMore": false
  }
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск клиента и проверка принадлежности к ресторану
3. Построение запроса: `SELECT b.*, t.table_number FROM bookings b JOIN tables t ON b.table_id = t.id JOIN rooms r ON t.room_id = r.id JOIN floors f ON r.floor_id = f.id WHERE b.client_id = :clientId AND f.restaurant_id = :id`
4. Применение фильтров (статус, даты)
5. Применение сортировки
6. Применение пагинации
7. Возврат списка с пагинацией

**Ошибки:**
- 400 Bad Request: невалидные query параметры
- 404 Not Found: клиент не найден или не связан с рестораном
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

### 3. API для истории предзаказов клиента

#### 3.1. GET `/admin-api/r/:id/client/:clientId/pre-order` - история предзаказов клиента
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `clientId` - long (required) - ID клиента

**Query параметры:**
- `limit` - integer (optional, default: 50, min: 1, max: 100)
- `offset` - integer (optional, default: 0, min: 0)
- `statusCode` - string (optional) - фильтр по коду статуса: "PENDING", "APPROVED", "REJECTED", "CANCELLED"
- `dateFrom` - date (optional, format: YYYY-MM-DD) - фильтр по дате начала
- `dateTo` - date (optional, format: YYYY-MM-DD) - фильтр по дате окончания
- `sortBy` - string (optional, default: "date") - поле для сортировки: "date", "totalAmount", "createdAt"
- `sortOrder` - string (optional, default: "desc") - порядок сортировки: "asc" или "desc"

**Response 200 OK:**
```json
{
  "clientId": 1,
  "data": [
    {
      "id": 1,
      "date": "2024-01-15",
      "time": "19:00:00",
      "totalAmount": 3500.00,
      "status": "APPROVED",
      "itemsCount": 3,
      "createdAt": "2024-01-01T09:00:00Z"
    }
  ],
  "pagination": {
    "total": 3,
    "limit": 50,
    "offset": 0,
    "hasMore": false
  }
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск клиента и проверка принадлежности к ресторану
3. Построение запроса: `SELECT po.*, (SELECT COUNT(*) FROM pre_order_items WHERE pre_order_id = po.id) as items_count FROM pre_orders po WHERE po.client_id = :clientId AND po.restaurant_id = :id`
4. Применение фильтров (статус, даты)
5. Применение сортировки
6. Применение пагинации
7. Возврат списка с пагинацией

**Ошибки:**
- 400 Bad Request: невалидные query параметры
- 404 Not Found: клиент не найден или не связан с рестораном
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

### 4. Валидация и бизнес-логика

#### 4.1. Валидация параметров
- **search**: максимальная длина 255 символов, поиск по телефону и имени (LIKE)
- **dateFrom/dateTo**: формат YYYY-MM-DD, `dateFrom <= dateTo`
- **statusCode**: только значения "PENDING", "APPROVED", "REJECTED", "CANCELLED"

#### 4.2. Проверка принадлежности клиента к ресторану
- Клиент считается связанным с рестораном, если:
  - У клиента есть бронирования в этом ресторане: `EXISTS (SELECT 1 FROM bookings b JOIN tables t ON b.table_id = t.id JOIN rooms r ON t.room_id = r.id JOIN floors f ON r.floor_id = f.id WHERE b.client_id = :clientId AND f.restaurant_id = :id)`
  - ИЛИ у клиента есть предзаказы в этом ресторане: `EXISTS (SELECT 1 FROM pre_orders po WHERE po.client_id = :clientId AND po.restaurant_id = :id)`
- Если клиент не связан с рестораном → вернуть ошибку 404

#### 4.3. Оптимизация запросов
- Использование индексов на `client_id`, `restaurant_id`
- Кэширование статистики клиента (опционально)
- Ограничение количества записей в истории (пагинация)

## Результаты выполнения шага

По итогу выполнения этого шага должны быть созданы следующие артефакты и выполнены следующие проверки:

### Созданные компоненты:
1. ✅ Client Controller:
   - `GET /admin-api/r/:id/client` endpoint
   - `GET /admin-api/r/:id/client/:clientId` endpoint
   - `GET /admin-api/r/:id/client/:clientId/booking` endpoint
   - `GET /admin-api/r/:id/client/:clientId/pre-order` endpoint

2. ✅ Client Service:
   - Методы для получения списка клиентов
   - Методы для получения информации о клиенте
   - Методы для получения истории бронирований/предзаказов
   - Методы для поиска клиентов

3. ✅ Валидация:
   - Валидация параметров запросов
   - Проверка доступа к ресторану

### Функциональные проверки:
1. ✅ Просмотр клиентов работает:
   - Получение списка клиентов
   - Поиск по имени/телефону работает
   - Получение информации о клиенте

2. ✅ История бронирований работает:
   - Список бронирований клиента возвращается
   - Фильтрация работает

3. ✅ История предзаказов работает:
   - Список предзаказов клиента возвращается
   - Фильтрация работает

4. ✅ Проверка доступа работает:
   - Менеджер может просматривать только клиентов своего ресторана
   - ADMIN может просматривать клиентов всех ресторанов

### Критерии готовности:
- ✅ Все endpoints работают
- ✅ Проверка доступа через интерцептор работает
- ✅ Поиск работает корректно
- ✅ История бронирований/предзаказов работает
- ✅ Все функциональные проверки пройдены успешно

**Шаг считается выполненным**, когда все endpoints работают и все функциональные проверки пройдены успешно.


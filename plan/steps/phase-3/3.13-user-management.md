# Шаг 3.13: Управление пользователями

## Описание
Реализация CRUD операций для управления пользователями системы (ADMIN и MANAGER). Доступ только для ADMIN.

## Задачи

### 1. CRUD операции для пользователей

#### 1.1. POST `/admin-api/user` - создание пользователя
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Request Body:**
```json
{
  "email": "string (required, max 255, уникальный, email format)",
  "password": "string (required, min 8 символов)",
  "roleId": "integer (required)",
  "restaurantIds": "array of integers (optional, только для MANAGER, массив ID ресторанов)"
}
```

**Response 201 Created:**
```json
{
  "id": 1,
  "email": "manager@example.com",
  "roleId": 2,
  "roleName": "MANAGER",
  "isActive": true,
  "restaurants": [
    {
      "id": 1,
      "name": "Ресторан 1"
    }
  ],
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-01T00:00:00Z"
}
```

**Логика:**
1. Проверка доступа: только ADMIN может создавать пользователей
2. Валидация всех полей согласно правилам
3. Проверка уникальности email: `SELECT * FROM users WHERE email = :email AND is_active = true`
4. Хеширование пароля через BCrypt перед сохранением
5. Создание записи в таблице `users`
6. Если роль = MANAGER и указаны `restaurantIds`:
   - Проверить существование всех ресторанов
   - Создать записи в таблице `users_2_restaurants` для каждого ресторана
7. Установка `is_active = true`, `created_at = NOW()`, `updated_at = NOW()`
8. Возврат созданного пользователя (без пароля)

**Ошибки:**
- 400 Bad Request: невалидные данные, дубликат email, ресторан не найден
- 403 Forbidden: пользователь не ADMIN

#### 1.2. GET `/admin-api/user` - список пользователей
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Query параметры:**
- `limit` - integer (optional, default: 50, min: 1, max: 100) - количество результатов
- `offset` - integer (optional, default: 0, min: 0) - смещение для пагинации
- `search` - string (optional, max: 255) - поиск по email (LIKE)
- `roleId` - integer (optional, 1=ADMIN, 2=MANAGER) - фильтр по роли
- `isActive` - boolean (optional, default: true) - фильтр по активности
- `sortBy` - string (optional, default: "createdAt") - поле для сортировки: "email", "createdAt", "updatedAt"
- `sortOrder` - string (optional, default: "desc") - порядок сортировки: "asc" или "desc"

**Response 200 OK:**
```json
{
  "data": [
    {
      "id": 1,
      "email": "manager@example.com",
      "roleId": 2,
      "roleName": "MANAGER",
      "isActive": true,
      "restaurants": [
        {
          "id": 1,
          "name": "Ресторан 1"
        }
      ],
      "createdAt": "2024-01-01T00:00:00Z"
    }
  ],
  "pagination": {
    "total": 100,
    "limit": 50,
    "offset": 0,
    "hasMore": true
  }
}
```

**Логика:**
1. Построение запроса: `SELECT * FROM users WHERE is_active = :isActive`
2. Применение фильтра по роли (если указан)
3. Применение поиска по email (если указан)
4. Применение сортировки
5. Применение пагинации (LIMIT/OFFSET)
6. Для каждого пользователя: загрузка связанных ресторанов из `users_2_restaurants` (только для MANAGER)
7. Подсчет общего количества записей
8. Возврат списка с пагинацией (без паролей)

**Ошибки:**
- 400 Bad Request: невалидные query параметры
- 403 Forbidden: пользователь не ADMIN

#### 1.3. GET `/admin-api/user/:userId` - получение пользователя
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Path параметры:**
- `userId` - long (required) - ID пользователя

**Response 200 OK:**
```json
{
  "id": 1,
  "email": "manager@example.com",
  "roleId": 2,
  "roleName": "MANAGER",
  "isActive": true,
  "restaurants": [
    {
      "id": 1,
      "name": "Ресторан 1"
    }
  ],
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-01T00:00:00Z"
}
```

**Логика:**
1. Проверка доступа: только ADMIN
2. Поиск пользователя: `SELECT * FROM users WHERE id = :userId AND is_active = true`
3. Если пользователь не найден → 404 Not Found
4. Загрузка связанных ресторанов из `users_2_restaurants` (только для MANAGER)
5. Возврат пользователя (без пароля)

**Ошибки:**
- 404 Not Found: пользователь не найден
- 403 Forbidden: пользователь не ADMIN

#### 1.4. PUT `/admin-api/user/:userId` - обновление пользователя
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Path параметры:**
- `userId` - long (required) - ID пользователя

**Request Body:**
```json
{
  "email": "string (optional, max 255, уникальный, email format)",
  "password": "string (optional, min 8 символов, если указан - обновить пароль)",
  "roleId": "integer (optional)",
  "restaurantIds": "array of integers (optional, только для MANAGER, массив ID ресторанов)"
}
```

**Response 200 OK:**
```json
{
  "id": 1,
  "email": "manager@example.com",
  "roleId": 2,
  "roleName": "MANAGER",
  "isActive": true,
  "restaurants": [
    {
      "id": 1,
      "name": "Ресторан 1"
    }
  ],
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-01T00:00:00Z"
}
```

**Логика:**
1. Проверка доступа: только ADMIN
2. Поиск пользователя: `SELECT * FROM users WHERE id = :userId AND is_active = true`
3. Если пользователь не найден → 404 Not Found
4. Валидация всех полей (если указаны)
5. Если указан `email`: проверка уникальности (исключая текущего пользователя)
6. Если указан `password`: хеширование через BCrypt перед сохранением
7. Обновление полей пользователя
8. Если указан `roleId` и роль = MANAGER:
   - Удалить все существующие связи в `users_2_restaurants` для этого пользователя
   - Если указаны `restaurantIds`: создать новые связи
9. Если указан `roleId` и роль = ADMIN:
   - Удалить все связи в `users_2_restaurants` для этого пользователя
10. Установка `updated_at = NOW()`
11. Возврат обновленного пользователя (без пароля)

**Ошибки:**
- 400 Bad Request: невалидные данные, дубликат email, ресторан не найден
- 404 Not Found: пользователь не найден
- 403 Forbidden: пользователь не ADMIN

#### 1.5. DELETE `/admin-api/user/:userId` - удаление пользователя (soft delete)
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Path параметры:**
- `userId` - long (required) - ID пользователя

**Response 204 No Content**

**Логика:**
1. Проверка доступа: только ADMIN
2. Поиск пользователя: `SELECT * FROM users WHERE id = :userId AND is_active = true`
3. Если пользователь не найден → 404 Not Found
4. Проверка: нельзя удалить самого себя (сравнить `userId` с ID текущего пользователя)
5. Soft delete: установка `is_active = false`, `deleted_at = NOW()`
6. Удаление всех refresh tokens пользователя из таблицы `refresh_tokens`
7. Удаление всех связей в `users_2_restaurants` для этого пользователя
8. Возврат 204 No Content

**Ошибки:**
- 400 Bad Request: попытка удалить самого себя
- 404 Not Found: пользователь не найден
- 403 Forbidden: пользователь не ADMIN

#### 1.6. PUT `/admin-api/user/:userId/password` - сброс пароля
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Path параметры:**
- `userId` - long (required) - ID пользователя

**Request Body:**
```json
{
  "password": "string (required, min 8 символов)"
}
```

**Response 200 OK:**
```json
{
  "message": "Пароль успешно изменен"
}
```

**Логика:**
1. Проверка доступа: только ADMIN
2. Поиск пользователя: `SELECT * FROM users WHERE id = :userId AND is_active = true`
3. Если пользователь не найден → 404 Not Found
4. Валидация пароля: минимум 8 символов
5. Хеширование пароля через BCrypt
6. Обновление пароля в таблице `users`
7. Установка `updated_at = NOW()`
8. Удаление всех refresh tokens пользователя из таблицы `refresh_tokens` (принудительный выход из всех устройств)
9. Возврат успешного ответа

**Ошибки:**
- 400 Bad Request: невалидный пароль
- 404 Not Found: пользователь не найден
- 403 Forbidden: пользователь не ADMIN

#### 1.7. PUT `/admin-api/user/:userId/activate` - активация/деактивация пользователя
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Path параметры:**
- `userId` - long (required) - ID пользователя

**Request Body:**
```json
{
  "isActive": "boolean (required)"
}
```

**Response 200 OK:**
```json
{
  "id": 1,
  "email": "manager@example.com",
  "roleId": 2,
  "roleName": "MANAGER",
  "isActive": false,
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-01T00:00:00Z"
}
```

**Логика:**
1. Проверка доступа: только ADMIN
2. Поиск пользователя: `SELECT * FROM users WHERE id = :userId`
3. Если пользователь не найден → 404 Not Found
4. Проверка: нельзя деактивировать самого себя
5. Обновление `is_active = :isActive`, `updated_at = NOW()`
6. Если `isActive = false`: удаление всех refresh tokens пользователя из таблицы `refresh_tokens`
7. Возврат обновленного пользователя

**Ошибки:**
- 400 Bad Request: попытка деактивировать самого себя
- 404 Not Found: пользователь не найден
- 403 Forbidden: пользователь не ADMIN

#### 1.8. GET `/admin-api/role` - список ролей
**Доступ:** Только ADMIN (`@PreAuthorize("hasRole('ADMIN')")`)

**Query параметры:**
- Нет параметров

**Response 200 OK:**
```json
{
  "data": [
    {
      "id": 1,
      "code": "ADMIN",
      "name": "Администратор",
      "description": "Полный доступ ко всем функциям системы"
    },
    {
      "id": 2,
      "code": "MANAGER",
      "name": "Менеджер",
      "description": "Доступ к управлению рестораном"
    }
  ]
}
```

**Логика:**
1. Проверка доступа: только ADMIN
2. Построение запроса: `SELECT * FROM roles WHERE is_active = true ORDER BY id ASC`
3. Возврат списка всех активных ролей

**Ошибки:**
- 403 Forbidden: пользователь не ADMIN

**Примечание:** Этот endpoint используется для заполнения dropdown списка ролей в форме создания/редактирования пользователя на фронтенде.

### 2. Валидация данных

#### 2.1. Email
- Обязательное поле при создании
- Формат: email (regex: `/^[^\s@]+@[^\s@]+\.[^\s@]+$/`)
- Максимальная длина: 255 символов
- Уникальность: не должно быть другого активного пользователя с таким email

#### 2.2. Password
- Обязательное поле при создании
- Минимальная длина: 8 символов
- Хеширование через BCrypt перед сохранением

#### 2.3. RoleId
- Обязательное поле при создании
- Допустимые значения: 1 (ADMIN), 2 (MANAGER)
- Должен существовать в таблице `roles`

#### 2.4. RestaurantIds
- Опциональное поле
- Только для MANAGER
- Массив ID ресторанов
- Все рестораны должны существовать и быть активными

### 3. Безопасность

#### 3.1. Хеширование паролей
- Использовать BCrypt для хеширования паролей
- Никогда не возвращать пароль в ответах API
- При обновлении пароля: удалять все refresh tokens пользователя

#### 3.2. Проверка доступа
- Все endpoints доступны только для ADMIN
- Использовать `@PreAuthorize("hasRole('ADMIN')")` для всех endpoints
- Проверка: нельзя удалить или деактивировать самого себя

#### 3.3. Soft Delete
- Использовать soft delete для пользователей (`is_active = false`)
- При удалении: удалять все refresh tokens и связи с ресторанами

## Результаты выполнения шага

По итогу выполнения этого шага должны быть созданы следующие артефакты и выполнены следующие проверки:

### Созданные компоненты:
1. ✅ User Controller:
   - `POST /admin-api/user` endpoint
   - `GET /admin-api/user` endpoint
   - `GET /admin-api/user/:userId` endpoint
   - `PUT /admin-api/user/:userId` endpoint
   - `DELETE /admin-api/user/:userId` endpoint
   - `PUT /admin-api/user/:userId/password` endpoint
   - `PUT /admin-api/user/:userId/activate` endpoint

2. ✅ Role Controller:
   - `GET /admin-api/role` endpoint

3. ✅ User Service:
   - Методы для CRUD операций
   - Валидация данных
   - Хеширование паролей через BCrypt
   - Работа с связями `users_2_restaurants`

4. ✅ Role Service:
   - Метод для получения списка активных ролей

5. ✅ DTO классы:
   - `CreateUserRequest`
   - `UpdateUserRequest`
   - `ResetPasswordRequest`
   - `ActivateUserRequest`
   - `UserResponse`
   - `RoleResponse`

### Функциональные проверки:
1. ✅ Создание пользователя работает:
   - Создание ADMIN пользователя
   - Создание MANAGER пользователя с привязкой к ресторанам
   - Валидация всех полей
   - Хеширование пароля

2. ✅ Получение списка пользователей работает:
   - Фильтрация по роли
   - Поиск по email
   - Пагинация
   - Сортировка

3. ✅ Обновление пользователя работает:
   - Обновление email
   - Обновление пароля
   - Изменение роли
   - Обновление привязки к ресторанам

4. ✅ Удаление пользователя работает:
   - Soft delete
   - Удаление refresh tokens
   - Удаление связей с ресторанами
   - Защита от удаления самого себя

5. ✅ Сброс пароля работает:
   - Обновление пароля
   - Удаление всех refresh tokens

6. ✅ Активация/деактивация работает:
   - Изменение статуса
   - Удаление refresh tokens при деактивации
   - Защита от деактивации самого себя

7. ✅ Получение списка ролей работает:
   - GET запрос на `/admin-api/role` возвращает список активных ролей
   - Роли отображаются с id, code, name и description
   - Доступ только для ADMIN

8. ✅ Доступ только для ADMIN:
   - Все endpoints защищены `@PreAuthorize("hasRole('ADMIN')")`
   - MANAGER не может получить доступ

### Критерии готовности:
- ✅ Все CRUD операции для пользователей реализованы
- ✅ Endpoint для получения списка ролей реализован
- ✅ Валидация всех полей работает
- ✅ Хеширование паролей через BCrypt работает
- ✅ Работа с связями `users_2_restaurants` работает
- ✅ Все endpoints защищены для ADMIN
- ✅ Soft delete работает корректно
- ✅ Все функциональные проверки пройдены успешно

**Шаг считается выполненным**, когда:
- Все endpoints управления пользователями работают
- Валидация и безопасность работают корректно
- Все функциональные проверки пройдены успешно


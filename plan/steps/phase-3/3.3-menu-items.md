# Шаг 3.3: Меню (блюда)

## Описание
Реализация CRUD операций для блюд меню ресторана, управление ценами, описаниями и фотографиями.

## Задачи

### 1. CRUD для блюд (menu_items)

#### 1.1. POST `/admin-api/r/:id/menu-item` - создание блюда
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана

**Request Body:**
```json
{
  "name": "string (required, max 255)",
  "description": "string (optional, TEXT, max 10000)",
  "ingredients": "string (optional, TEXT, max 10000)",
  "price": "decimal (required, min: 0.01, precision: 10, scale: 2)",
  "menuCategoryId": "long (required, должен существовать в menu_categories и is_active = true)",
  "discountPercent": "integer (optional, default: 0, min: 0, max: 100)",
  "spicinessLevel": "integer (optional, default: 0, min: 0, max: 5)",
  "hasSugar": "boolean (optional, default: false)",
  "imageId": "long (optional, должен существовать в images и is_active = true)",
  "displayOrder": "integer (optional, default: 0, min: 0)"
}
```

**Response 201 Created:**
```json
{
  "id": 1,
  "restaurantId": 1,
  "menuCategoryId": 1,
  "name": "string",
  "description": "string | null",
  "ingredients": "string | null",
  "price": 1000.50,
  "discountPercent": 10,
  "finalPrice": 900.45,
  "spicinessLevel": 2,
  "hasSugar": false,
  "imageId": 123,
  "displayOrder": 0,
  "isActive": true,
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-01T00:00:00Z",
  "deletedAt": null
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Проверка существования ресторана с `is_active = true`
3. Валидация всех полей согласно правилам
4. Проверка существования и активности категории меню: `SELECT * FROM menu_categories WHERE id = :menuCategoryId AND is_active = true`
5. Проверка существования и активности изображения (если указано `imageId`)
6. Создание записи в таблице `menu_items`
7. Установка `restaurant_id = :id`, `is_active = true`, `created_at = NOW()`, `updated_at = NOW()`
8. Расчет `finalPrice = price * (1 - discountPercent / 100)` для ответа
9. Возврат созданного блюда с рассчитанной финальной ценой

**Ошибки:**
- 400 Bad Request: невалидные данные, категория не найдена или неактивна, изображение не найдено или неактивно
- 404 Not Found: ресторан не найден или неактивен
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 1.2. GET `/admin-api/r/:id/menu-item` - список блюд ресторана
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана

**Query параметры:**
- `limit` - integer (optional, default: 50, min: 1, max: 100) - количество результатов
- `offset` - integer (optional, default: 0, min: 0) - смещение для пагинации
- `menuCategoryId` - long (optional) - фильтр по категории меню
- `isActive` - boolean (optional, default: true) - фильтр по активности
- `search` - string (optional, max: 255) - поиск по названию (LIKE)
- `sortBy` - string (optional, default: "displayOrder") - поле для сортировки: "name", "price", "displayOrder", "createdAt"
- `sortOrder` - string (optional, default: "asc") - порядок сортировки: "asc" или "desc"

**Логика доступа:**
- **ADMIN**: доступ к любым ресторанам
- **MANAGER**: доступ только через интерцептор `/r/*`

**Response 200 OK:**
```json
{
  "data": [
    {
      "id": 1,
      "restaurantId": 1,
      "menuCategoryId": 1,
      "name": "string",
      "description": "string | null",
      "ingredients": "string | null",
      "price": 1000.50,
      "discountPercent": 10,
      "finalPrice": 900.45,
      "spicinessLevel": 2,
      "hasSugar": false,
      "imageId": 123,
      "displayOrder": 0,
      "isActive": true,
      "createdAt": "2024-01-01T00:00:00Z"
    }
  ],
  "pagination": {
    "total": 100,
    "limit": 50,
    "offset": 0,
    "hasMore": true
  }
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск ресторана по ID с `is_active = true`
3. Построение запроса: `SELECT * FROM menu_items WHERE restaurant_id = :id AND is_active = :isActive`
4. Применение фильтров:
   - По категории: `AND menu_category_id = :menuCategoryId` (если указано)
   - По поиску: `AND name ILIKE '%:search%'` (если указано)
5. Применение сортировки
6. Применение пагинации (LIMIT/OFFSET)
7. Подсчет общего количества записей
8. Расчет `finalPrice` для каждого блюда в ответе
9. Возврат списка с пагинацией

**Ошибки:**
- 400 Bad Request: невалидные query параметры
- 404 Not Found: ресторан не найден или неактивен
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 1.3. GET `/admin-api/r/:id/menu-item/:itemId` - получение блюда
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `itemId` - long (required) - ID блюда

**Response 200 OK:**
```json
{
  "id": 1,
  "restaurantId": 1,
  "menuCategoryId": 1,
  "name": "string",
  "description": "string | null",
  "ingredients": "string | null",
  "price": 1000.50,
  "discountPercent": 10,
  "finalPrice": 900.45,
  "spicinessLevel": 2,
  "hasSugar": false,
  "imageId": 123,
  "displayOrder": 0,
  "isActive": true,
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-01T00:00:00Z",
  "deletedAt": null
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск блюда: `SELECT * FROM menu_items WHERE id = :itemId AND restaurant_id = :id AND is_active = true`
3. Расчет `finalPrice = price * (1 - discountPercent / 100)`
4. Возврат блюда с рассчитанной финальной ценой

**Ошибки:**
- 404 Not Found: блюдо не найдено, неактивно или не принадлежит ресторану
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 1.4. PUT `/admin-api/r/:id/menu-item/:itemId` - обновление блюда
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `itemId` - long (required) - ID блюда

**Request Body:**
```json
{
  "name": "string (optional, max 255)",
  "description": "string (optional, TEXT, max 10000)",
  "ingredients": "string (optional, TEXT, max 10000)",
  "price": "decimal (optional, min: 0.01)",
  "menuCategoryId": "long (optional, должен существовать и быть активным)",
  "discountPercent": "integer (optional, min: 0, max: 100)",
  "spicinessLevel": "integer (optional, min: 0, max: 5)",
  "hasSugar": "boolean (optional)",
  "imageId": "long | null (optional)",
  "displayOrder": "integer (optional, min: 0)"
}
```

**Response 200 OK:**
```json
{
  "id": 1,
  "restaurantId": 1,
  "menuCategoryId": 1,
  "name": "string",
  "description": "string | null",
  "ingredients": "string | null",
  "price": 1000.50,
  "discountPercent": 10,
  "finalPrice": 900.45,
  "spicinessLevel": 2,
  "hasSugar": false,
  "imageId": 123,
  "displayOrder": 0,
  "isActive": true,
  "createdAt": "2024-01-01T00:00:00Z",
  "updatedAt": "2024-01-01T00:00:00Z",
  "deletedAt": null
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск блюда: `SELECT * FROM menu_items WHERE id = :itemId AND restaurant_id = :id AND is_active = true`
3. Валидация всех переданных полей
4. Проверка существования и активности категории (если изменяется `menuCategoryId`): `SELECT * FROM menu_categories WHERE id = :menuCategoryId AND is_active = true`
5. Проверка существования и активности изображения (если изменяется `imageId`)
7. Обновление только переданных полей (PATCH-логика)
8. Установка `updated_at = NOW()`
9. Расчет `finalPrice` для ответа
10. Возврат обновленного блюда

**Ошибки:**
- 400 Bad Request: невалидные данные, категория не найдена или неактивна, изображение не найдено или неактивно
- 404 Not Found: блюдо не найдено, неактивно или не принадлежит ресторану
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 1.5. DELETE `/admin-api/r/:id/menu-item/:itemId` - удаление блюда
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана
- `itemId` - long (required) - ID блюда

**Response 204 No Content**

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Поиск блюда: `SELECT * FROM menu_items WHERE id = :itemId AND restaurant_id = :id AND is_active = true`
3. Проверка использования блюда:
   - Проверка наличия активных предзаказов с этим блюдом: `SELECT COUNT(*) FROM pre_order_items WHERE menu_item_id = :itemId AND pre_order_id IN (SELECT id FROM pre_orders WHERE booking_status_id != (SELECT id FROM booking_statuses WHERE code = 'CANCELLED'))`
   - Если есть активные предзаказы → вернуть ошибку 400 (опционально, можно разрешить удаление)
4. Мягкое удаление:
   - Установка `is_active = false`
   - Установка `deleted_at = NOW()`
   - Установка `updated_at = NOW()`

**Ошибки:**
- 404 Not Found: блюдо не найдено, неактивно или не принадлежит ресторану
- 400 Bad Request: блюдо используется в активных предзаказах (если проверка включена)
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

#### 1.6. PUT `/admin-api/r/:id/menu-item/reorder` - массовое обновление порядка блюд
**Доступ:** ADMIN и MANAGER (через интерцептор `/r/*`)

**Path параметры:**
- `id` - long (required) - ID ресторана

**Request Body:**
```json
{
  "items": [
    { "id": 1, "displayOrder": 0 },
    { "id": 2, "displayOrder": 1 },
    { "id": 3, "displayOrder": 2 }
  ]
}
```

**Валидация:**
- `items` - массив объектов (required, min: 1)
- Каждый объект должен содержать:
  - `id` - long (required) - ID блюда
  - `displayOrder` - integer (required, min: 0) - новый порядок отображения
- Все ID должны существовать в таблице `menu_items` и принадлежать ресторану `:id`
- Все блюда должны быть активными (`is_active = true`)

**Response 200 OK:**
```json
{
  "message": "Order updated successfully",
  "updatedCount": 3
}
```

**Логика:**
1. Проверка доступа через интерцептор `/r/*` (для MANAGER)
2. Валидация массива `items`:
   - Проверка, что массив не пустой
   - Проверка, что все ID существуют и принадлежат ресторану
   - Проверка, что все блюда активны
3. Обновление `display_order` для каждого блюда:
   - `UPDATE menu_items SET display_order = :displayOrder, updated_at = NOW() WHERE id = :itemId AND restaurant_id = :id AND is_active = true`
4. Установка `updated_at = NOW()` для всех обновленных блюд
5. Возврат количества обновленных записей

**Ошибки:**
- 400 Bad Request: невалидные данные, блюдо не найдено, неактивно или не принадлежит ресторану
- 404 Not Found: ресторан не найден или неактивен
- 403 Forbidden: MANAGER не имеет доступа к этому ресторану

### 2. Валидация полей блюда

#### 2.1. Правила валидации для каждого поля

**name** (название):
- Обязательное поле (`@NotNull`)
- Максимальная длина: 255 символов (`@Size(max = 255)`)
- Не может быть пустой строкой (после trim)
- Валидатор: `@NotBlank`, `@Size(max = 255)`

**description** (описание):
- Опциональное поле (`nullable = true`)
- Тип: TEXT (без ограничения длины в БД)
- Максимальная длина на уровне валидации: 10000 символов (`@Size(max = 10000)`)

**ingredients** (ингредиенты):
- Опциональное поле (`nullable = true`)
- Тип: TEXT (без ограничения длины в БД)
- Максимальная длина на уровне валидации: 10000 символов (`@Size(max = 10000)`)

**price** (цена):
- Обязательное поле (`@NotNull`)
- Тип: DECIMAL(10, 2)
- Минимальное значение: 0.01 (`@DecimalMin("0.01")`)
- Положительное число (`@Positive`)
- Валидатор: `@NotNull`, `@DecimalMin("0.01")`, `@Digits(integer = 8, fraction = 2)`

**menuCategoryId** (ID категории меню):
- Обязательное поле (`@NotNull`)
- Тип: BIGINT
- Кастомная валидация:
  - Должно существовать в таблице `menu_categories`
  - Категория должна быть активной (`is_active = true`)
  - Кастомный валидатор: `@ValidMenuCategoryId` - проверка через сервис

**discountPercent** (процент скидки):
- Опциональное поле (default: 0)
- Тип: INTEGER
- Диапазон: от 0 до 100 (`@Min(0)`, `@Max(100)`)
- Валидатор: `@Min(0)`, `@Max(100)`

**spicinessLevel** (уровень остроты):
- Опциональное поле (default: 0)
- Тип: INTEGER
- Диапазон: от 0 до 5 (`@Min(0)`, `@Max(5)`)
- Валидатор: `@Min(0)`, `@Max(5)`

**hasSugar** (содержит сахар):
- Опциональное поле (default: false)
- Тип: BOOLEAN
- Валидатор: стандартная валидация boolean

**imageId** (ID изображения):
- Опциональное поле (`nullable = true`)
- Тип: BIGINT
- Кастомная валидация:
  - Если указано, должно существовать в таблице `images`
  - Изображение должно быть активным (`is_active = true`)
  - Кастомный валидатор: `@ValidImageId` - проверка через сервис

**displayOrder** (порядок отображения):
- Опциональное поле (default: 0)
- Тип: INTEGER
- Минимальное значение: 0 (`@Min(0)`)
- Валидатор: `@Min(0)`

#### 2.2. Кастомные валидаторы

**@ValidMenuCategoryId** - валидация существования и активности категории меню:
```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ValidMenuCategoryIdValidator.class)
public @interface ValidMenuCategoryId {
    String message() default "Menu category not found or inactive";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```
- Проверка через `MenuCategoryRepository.findByIdAndIsActiveTrue(categoryId)`
- Возвращает ошибку, если категория не найдена или неактивна

**@ValidImageId** - валидация существования и активности изображения:
```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ValidImageIdValidator.class)
public @interface ValidImageId {
    String message() default "Image not found or inactive";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```
- Проверка через `ImageRepository.findByIdAndIsActiveTrue(imageId)`
- Возвращает ошибку, если изображение не найдено или неактивно

#### 2.3. Логика проверки существования связанных сущностей

**Проверка категории меню:**
1. При создании/обновлении блюда с `menuCategoryId`:
   - Выполнить запрос: `SELECT * FROM menu_categories WHERE id = :menuCategoryId AND is_active = true`
   - Если категория не найдена или неактивна → вернуть ошибку 400

**Проверка изображения:**
1. При создании/обновлении блюда с `imageId`:
   - Выполнить запрос: `SELECT * FROM images WHERE id = :imageId AND is_active = true`
   - Если изображение не найдено или неактивно → вернуть ошибку 400

**Проверка принадлежности блюда к ресторану:**
1. При получении/обновлении/удалении блюда:
   - Выполнить запрос: `SELECT * FROM menu_items WHERE id = :itemId AND restaurant_id = :restaurantId AND is_active = true`
   - Если блюдо не найдено или не принадлежит ресторану → вернуть ошибку 404

### 3. Расчет цены со скидкой

#### 3.1. Формула расчета
- **Финальная цена** = `price * (1 - discountPercent / 100)`
- Округление до 2 знаков после запятой (для денег)
- Пример: `price = 1000.50`, `discountPercent = 10` → `finalPrice = 1000.50 * 0.9 = 900.45`

#### 3.2. Логика применения
- Расчет выполняется на уровне API при получении блюда (GET запросы)
- Базовая цена (`price`) и процент скидки (`discountPercent`) хранятся в БД
- Финальная цена (`finalPrice`) вычисляется динамически и добавляется в Response DTO
- При создании/обновлении блюда в БД сохраняются только `price` и `discountPercent`

#### 3.3. Обработка граничных случаев
- Если `discountPercent = 0` → `finalPrice = price`
- Если `discountPercent = 100` → `finalPrice = 0` (бесплатно)
- Если `discountPercent > 100` → ошибка валидации (не должно быть больше 100)
- Округление: использовать `BigDecimal` для точных вычислений, округление через `setScale(2, RoundingMode.HALF_UP)`

### 4. Фотографии блюд

#### 4.1. Загрузка изображения
- Загрузка через `/admin-api/image` (см. шаг 3.1)
- Сохранение `image_id` в поле `image_id` блюда
- Одно изображение на блюдо (на первом этапе)
- Автоматическая генерация превью при загрузке

#### 4.2. Отвязка изображения
- Установка `imageId = null` через PUT запрос
- Изображение остается в таблице `images` (не удаляется автоматически)

### 5. Логика soft delete

#### 5.1. Поведение при удалении
- Установка `is_active = false` и `deleted_at = NOW()`
- Блюдо скрывается из всех GET запросов (фильтр `is_active = true`)
- Блюдо остается в БД для истории и статистики

#### 5.2. Проверка использования перед удалением (опционально)
- Проверка наличия активных предзаказов с этим блюдом
- Если проверка включена и есть активные предзаказы → вернуть ошибку 400
- Если проверка отключена → разрешить удаление (блюдо просто скрывается)

## Результаты выполнения шага

По итогу выполнения этого шага должны быть созданы следующие артефакты и выполнены следующие проверки:

### Созданные компоненты:
1. ✅ MenuItem Controller:
   - `POST /admin-api/r/:id/menu-item` endpoint
   - `GET /admin-api/r/:id/menu-item` endpoint
   - `GET /admin-api/r/:id/menu-item/:itemId` endpoint
   - `PUT /admin-api/r/:id/menu-item/:itemId` endpoint
   - `PUT /admin-api/r/:id/menu-item/reorder` endpoint
   - `DELETE /admin-api/r/:id/menu-item/:itemId` endpoint

2. ✅ MenuItem Service:
   - Методы для CRUD операций
   - Валидация данных
   - Проверка доступа к ресторану
   - Расчет цены со скидкой

3. ✅ Валидация:
   - Валидация обязательных полей
   - Валидация цен и процентов
   - Проверка существования категории

### Функциональные проверки:
1. ✅ CRUD операции работают:
   - Создание блюда
   - Получение списка блюд (с фильтрацией по категории)
   - Получение блюда по ID
   - Обновление блюда
   - Массовое обновление порядка блюд
   - Мягкое удаление блюда

2. ✅ Проверка доступа работает:
   - Менеджер может работать только со своими ресторанами
   - ADMIN может работать с любыми ресторанами

3. ✅ Валидация работает:
   - Обязательные поля проверяются
   - Цены и проценты валидируются
   - Проверка существования категории

4. ✅ Расчет цены со скидкой работает:
   - Финальная цена рассчитывается корректно
   - Базовая цена хранится в БД

### Критерии готовности:
- ✅ Все CRUD endpoints работают
- ✅ Проверка доступа через интерцептор работает
- ✅ Валидация данных работает
- ✅ Мягкое удаление работает корректно
- ✅ Расчет цены со скидкой работает
- ✅ Все функциональные проверки пройдены успешно

**Шаг считается выполненным**, когда все endpoints работают и все функциональные проверки пройдены успешно.


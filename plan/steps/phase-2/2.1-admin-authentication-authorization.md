# Шаг 2.1: Аутентификация и авторизация для Admin API

## Описание
Реализация системы аутентификации и авторизации для admin-api и admin-web с двумя ролями: Администратор и Менеджер ресторана. Использование JWT токенов, Spring Security, @PreAuthorize для защиты endpoints.

## Технологии
- **Spring Security** - фреймворк безопасности
- **JWT (JSON Web Tokens)** - для аутентификации
- **JJWT** или **java-jwt** - библиотека для работы с JWT
- **BCrypt** - хеширование паролей
- **Spring Cloud Sleuth** - для traceId в логах и error response
- **MDC (Mapped Diagnostic Context)** - для traceId в логах

## Задачи

### 1. Реализация ролей
- **Администратор системы (ADMIN)**: полный доступ ко всем функциям, доступ ко всем ресторанам
- **Менеджер ресторана (MANAGER)**: доступ только к своим ресторанам (проверка через интерцептор)

### 2. Структура JWT токена
- В токене хранится только **роль** (ADMIN или MANAGER)
- Токен содержит `exp` (expiration time) - фронт должен проверять срок действия
- Access token: срок жизни **5 минут**
- Refresh token: срок жизни **60 минут**
- Алгоритм подписи: надежный (RS256 или HS256 с длинным ключом)
- Секретный ключ хранится в переменных окружения

### 3. Таблица refresh_tokens
- Создать таблицу `refresh_tokens` в БД:
  - `id` - BIGSERIAL PRIMARY KEY
  - `user_id` - BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE
  - `token` - VARCHAR(500) UNIQUE NOT NULL (хеш refresh token)
  - `expires_at` - TIMESTAMP NOT NULL
  - `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- При создании refresh token: сохранять хеш токена в БД
- При использовании refresh token: проверять существование и срок действия
- При logout: удалять refresh token из БД

### 3.1. Таблица password_reset_codes
- Создать таблицу `password_reset_codes` в БД:
  - `id` - BIGSERIAL PRIMARY KEY
  - `user_id` - BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE
  - `code` - VARCHAR(255) NOT NULL (хеш кода восстановления)
  - `email` - VARCHAR(255) NOT NULL (email пользователя на момент запроса)
  - `expires_at` - TIMESTAMP NOT NULL (время истечения кода)
  - `used` - BOOLEAN NOT NULL DEFAULT FALSE (использован ли код)
  - `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
  - `used_at` - TIMESTAMP NULL (когда код был использован)
- Индекс на `user_id` для быстрого поиска
- Индекс на `code` (хеш) для быстрого поиска при валидации
- При создании кода: сохранять хеш кода в БД
- При использовании кода: устанавливать `used = true` и `used_at = NOW()`
- Автоматическая очистка: удалять истекшие коды (через scheduled task или при проверке)
- Код восстановления: 6-значный числовой код (например: 123456)
- Время жизни кода: 15 минут

### 4. Хеширование паролей
- Использовать **BCrypt** для хеширования паролей
- При создании/обновлении пользователя: хешировать пароль перед сохранением
- При аутентификации: проверять пароль через BCrypt

### 5. API endpoints для аутентификации
- **POST `/auth/login`** - вход в систему
  - Request: `{ "email": "...", "password": "..." }`
  - Response: `{ "accessToken": "...", "refreshToken": "...", "role": "ADMIN" | "MANAGER", "expiresIn": 300 }` (expiresIn в секундах для access token)
  - **Ошибки:**
    - **401 Unauthorized** с `exceptionName: "INVALID_CREDENTIALS"` - если email или пароль неверны
    - **400 Bad Request** с `exceptionName: "MISSING_CREDENTIALS"` - если email или пароль не переданы
- **POST `/auth/logout`** - выход из системы
  - Удаляет refresh token из БД
  - Требует аутентификации
- **POST `/auth/refresh`** - обновление access token
  - Request: `{ "refreshToken": "..." }`
  - Response: `{ "accessToken": "...", "refreshToken": "...", "expiresIn": 300 }` (expiresIn в секундах)
  - **Ошибки:**
    - **401 Unauthorized** с `exceptionName: "REFRESH_TOKEN_EXPIRED"` - если refresh token истек или не найден
    - **401 Unauthorized** с `exceptionName: "INVALID_REFRESH_TOKEN"` - если refresh token невалиден
    - **400 Bad Request** с `exceptionName: "MISSING_REFRESH_TOKEN"` - если refreshToken не передан
  - При ошибке фронт должен отправить пользователя на релогин
- **GET `/auth/me`** - получение информации о текущем пользователе
  - Response для MANAGER: 
    ```json
    {
      "id": 1,
      "email": "manager@example.com",
      "role": "MANAGER",
      "restaurants": [
        {
          "id": 1,
          "name": "Ресторан 1",
          "subscription": {
            "restaurantId": 1,
            "isActive": true,
            "endDate": "2024-01-31",
            "daysRemaining": 5,
            "isExpiringSoon": true
          }
        }
      ]
    }
    ```
  - Response для ADMIN:
    ```json
    {
      "id": 1,
      "email": "admin@example.com",
      "role": "ADMIN",
      "restaurants": []
    }
    ```
  - **Информация о подписке** (для MANAGER):
    - Для каждого ресторана в массиве `restaurants` включить объект `subscription`
    - Формат `subscription`:
      ```json
      {
        "restaurantId": 1,
        "isActive": true,
        "endDate": "2024-01-31",
        "daysRemaining": 5,
        "isExpiringSoon": true
      }
      ```
    - Если подписки нет или неактивна: `subscription: null` или `subscription: { "isActive": false, "daysRemaining": 0, "isExpiringSoon": false }`
    - `isExpiringSoon: true` если `daysRemaining <= 7`
    - `daysRemaining` вычисляется как `endDate - CURRENT_DATE` (в днях)
- **POST `/auth/forgot-password`** - запрос на восстановление пароля
  - Request: `{ "email": "..." }`
  - Response: `{ "message": "Код восстановления отправлен на email" }`
  - **Логика:**
    1. Проверка существования пользователя с таким email и `is_active = true`
    2. Если пользователь не найден → вернуть успешный ответ (без раскрытия информации о существовании пользователя)
    3. Если пользователь найден:
       - Сгенерировать 6-значный числовой код (например: 123456)
       - Захешировать код через BCrypt или SHA-256
       - Сохранить хеш кода в таблицу `password_reset_codes`:
         - `user_id` = ID пользователя
         - `code` = хеш кода
         - `email` = email пользователя
         - `expires_at` = NOW() + 15 минут
         - `used` = false
       - Отправить email с кодом на адрес пользователя
       - Удалить старые неиспользованные коды для этого пользователя (опционально)
  - **Ошибки:**
    - **400 Bad Request** с `exceptionName: "MISSING_EMAIL"` - если email не передан
    - **400 Bad Request** с `exceptionName: "INVALID_EMAIL"` - если email невалиден
  - **Безопасность:** Всегда возвращать успешный ответ, даже если пользователь не найден (защита от перебора email)
- **POST `/auth/reset-password`** - установка нового пароля по коду
  - Request: `{ "email": "...", "code": "123456", "newPassword": "..." }`
  - Response: `{ "message": "Пароль успешно изменен" }`
  - **Логика:**
    1. Валидация всех полей (email, code, newPassword)
    2. Поиск пользователя по email с `is_active = true`
    3. Если пользователь не найден → 404 Not Found
    4. Поиск активного кода восстановления:
       - `SELECT * FROM password_reset_codes WHERE user_id = :userId AND used = false AND expires_at > NOW() ORDER BY created_at DESC LIMIT 1`
    5. Проверка кода: сравнить хеш переданного кода с хешем в БД
    6. Если код не найден или неверен → 400 Bad Request с `exceptionName: "INVALID_RESET_CODE"`
    7. Если код истек → 400 Bad Request с `exceptionName: "RESET_CODE_EXPIRED"`
    8. Если код уже использован → 400 Bad Request с `exceptionName: "RESET_CODE_ALREADY_USED"`
    9. Валидация нового пароля: минимум 8 символов
    10. Хеширование нового пароля через BCrypt
    11. Обновление пароля в таблице `users`
    12. Установка `used = true` и `used_at = NOW()` для кода восстановления
    13. Удаление всех refresh tokens пользователя из таблицы `refresh_tokens` (принудительный выход из всех устройств)
    14. Возврат успешного ответа
  - **Ошибки:**
    - **400 Bad Request** с `exceptionName: "MISSING_FIELDS"` - если не переданы обязательные поля
    - **400 Bad Request** с `exceptionName: "INVALID_EMAIL"` - если email невалиден
    - **400 Bad Request** с `exceptionName: "INVALID_RESET_CODE"` - если код неверен
    - **400 Bad Request** с `exceptionName: "RESET_CODE_EXPIRED"` - если код истек
    - **400 Bad Request** с `exceptionName: "RESET_CODE_ALREADY_USED"` - если код уже использован
    - **400 Bad Request** с `exceptionName: "INVALID_PASSWORD"` - если пароль невалиден (меньше 8 символов)
    - **404 Not Found** с `exceptionName: "USER_NOT_FOUND"` - если пользователь не найден

### 6. Отправка email для восстановления пароля
- Использовать Spring Mail или внешний сервис (SendGrid, AWS SES и т.д.)
- Шаблон email:
  - Тема: "Восстановление пароля Resto-Hub"
  - Текст: "Ваш код восстановления пароля: {code}. Код действителен в течение 15 минут."
  - Предупреждение о безопасности (не передавать код третьим лицам)
- Настройка SMTP в application.properties или переменных окружения
- Обработка ошибок отправки email (логирование, не блокировать процесс)

### 7. Spring Security конфигурация
- Настроить SecurityFilterChain
- Настроить JWT фильтр для валидации токенов
- Настроить CORS для admin-web
- Настроить CSRF защиту
- Настроить rate limiting для `/auth/login` (защита от брутфорса)
- Настроить rate limiting для `/auth/forgot-password` (защита от спама, например: максимум 3 запроса в час с одного IP)
- Публичные endpoints: `/auth/login`, `/auth/refresh`, `/auth/forgot-password`, `/auth/reset-password`
- Защищенные endpoints: все остальные (требуют JWT токен)

### 7. Использование @PreAuthorize
- Использовать `@PreAuthorize("hasRole('ADMIN')")` для endpoints только для администраторов
- Использовать `@PreAuthorize("hasRole('MANAGER')")` или `@PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")` для endpoints для менеджеров
- Использовать `@PreAuthorize("hasRoles('ADMIN', 'MANAGER')")` для массивов ролей

### 8. Интерцептор для проверки принадлежности менеджера к ресторану
- Создать интерцептор для проверки доступа менеджера к ресторану
- Интерцептор применяется ко всем endpoints с basePath `/r/*` (короткий путь вместо `/restaurant/*`)
- Интерцептор извлекает `restaurantId` из path variable (например, `/r/{restaurantId}/menu`)
- Если роль пользователя = ADMIN: пропускать запрос без проверки
- Если роль пользователя = MANAGER: проверять, что пользователь имеет доступ к ресторану через таблицу `users_2_restaurants`
- Если менеджер пытается получить доступ к чужому ресторану: возвращать ошибку с кодом **ACCESS_DENIED** и HTTP статусом 403

### 9. Единый формат ошибок (Error Response)
- Создать глобальный exception handler (@ControllerAdvice)
- Все ошибки возвращаются в едином формате:
  ```json
  {
    "exceptionName": "RESTAURANT_NOT_FOUND",
    "message": "Ресторан с ID 123 не найден",
    "timestamp": "2024-01-01T12:00:00Z",
    "traceId": "abc123..."
  }
  ```
- HTTP статусы: 4xx для клиентских ошибок, 5xx для серверных ошибок
- Фронт реагирует как на HTTP статусы, так и на exceptionName в response body

**Ошибки аутентификации:**
- **401 Unauthorized** с `exceptionName: "TOKEN_EXPIRED"` - если access token истек (при обычном запросе)
- **401 Unauthorized** с `exceptionName: "REFRESH_TOKEN_EXPIRED"` - если refresh token истек (при refresh)
- **401 Unauthorized** с `exceptionName: "INVALID_TOKEN"` - если токен невалиден
- **401 Unauthorized** с `exceptionName: "INVALID_REFRESH_TOKEN"` - если refresh token невалиден
- **401 Unauthorized** с `exceptionName: "UNAUTHORIZED"` - если токен отсутствует или общая ошибка авторизации

### 10. Spring Cloud Sleuth и MDC
- Настроить Spring Cloud Sleuth для генерации traceId
- Настроить MDC для добавления traceId в логи
- traceId должен быть доступен в:
  - Error response (через @ControllerAdvice)
  - Логах приложения (через MDC)

### 11. Frontend (admin-web) - работа с токенами
- Декодировать JWT токен на клиенте для получения роли
- Использовать роль для показа/скрытия элементов интерфейса (через контекст React или хуки)
- Проверять срок действия access token перед каждым запросом
- Если access token истек: автоматически обновлять через refresh token
- Если refresh token истек: перенаправлять пользователя на страницу логина
- Хранить токены в localStorage или HTTP-only cookies (на усмотрение)

## Результаты выполнения шага

По итогу выполнения этого шага должны быть созданы следующие артефакты и выполнены следующие проверки:

### Созданные компоненты:
1. ✅ Таблица `refresh_tokens` в БД:
   - Миграция создана и применена
   - Таблица содержит все необходимые поля
   - Связь с таблицей `users` настроена

2. ✅ Таблица `password_reset_codes` в БД:
   - Миграция создана и применена
   - Таблица содержит все необходимые поля
   - Связь с таблицей `users` настроена
   - Индексы на `user_id` и `code` созданы

3. ✅ Entity и Repository:
   - `RefreshToken` Entity класс
   - `RefreshTokenRepository` интерфейс
   - `PasswordResetCode` Entity класс
   - `PasswordResetCodeRepository` интерфейс

4. ✅ JWT утилиты:
   - Класс для генерации JWT токенов
   - Класс для валидации JWT токенов
   - Извлечение роли из токена

5. ✅ Spring Security конфигурация:
   - `SecurityConfig` класс с настройкой SecurityFilterChain
   - JWT фильтр для валидации токенов
   - Настроен CORS
   - Настроена CSRF защита
   - Настроен rate limiting для `/auth/login`
   - Настроен rate limiting для `/auth/forgot-password`

6. ✅ Authentication Service:
   - `AuthenticationService` с методами login, logout, refresh
   - Хеширование паролей через BCrypt
   - Работа с refresh tokens

7. ✅ Authentication Controller:
   - `POST /auth/login` endpoint
   - `POST /auth/logout` endpoint
   - `POST /auth/refresh` endpoint
   - `GET /auth/me` endpoint
   - `POST /auth/forgot-password` endpoint
   - `POST /auth/reset-password` endpoint

8. ✅ Password Reset Service:
   - `PasswordResetService` с методами для генерации кода, отправки email, валидации кода
   - Генерация 6-значного числового кода
   - Хеширование кода через BCrypt или SHA-256
   - Отправка email через Spring Mail или внешний сервис

9. ✅ Интерцептор для проверки доступа к ресторану:
   - Интерцептор применяется к `/r/*` endpoints
   - Проверяет доступ менеджера к ресторану
   - Пропускает запросы для ADMIN

10. ✅ Глобальный Exception Handler:
   - `@ControllerAdvice` класс
   - Единый формат error response
   - traceId в error response

11. ✅ Настройка Spring Cloud Sleuth и MDC:
   - Sleuth настроен для генерации traceId
   - MDC настроен для добавления traceId в логи
   - traceId доступен в логах и error response

### Функциональные проверки:
1. ✅ Аутентификация работает:
   - Логин с правильными credentials возвращает access и refresh токены
   - Логин с неправильными credentials возвращает ошибку
   - Роль корректно извлекается из токена

2. ✅ JWT токены работают:
   - Access token имеет срок жизни 5 минут
   - Refresh token имеет срок жизни 60 минут
   - Токены содержат роль пользователя
   - Токены валидируются корректно

3. ✅ Refresh token работает:
   - Refresh token сохраняется в БД при логине
   - Обновление access token через refresh token работает
   - При истечении refresh token возвращается 401 с `exceptionName: "REFRESH_TOKEN_EXPIRED"`
   - При невалидном refresh token возвращается 401 с `exceptionName: "INVALID_REFRESH_TOKEN"`
   - При logout refresh token удаляется из БД

4. ✅ @PreAuthorize работает:
   - Endpoints с `@PreAuthorize("hasRole('ADMIN')")` доступны только администраторам
   - Endpoints с `@PreAuthorize("hasRole('MANAGER')")` доступны менеджерам
   - Неавторизованные запросы возвращают 401

5. ✅ Интерцептор проверки доступа к ресторану работает:
   - ADMIN может обращаться к любому ресторану
   - MANAGER может обращаться только к своим ресторанам
   - MANAGER не может обращаться к чужим ресторанам (403 ACCESS_DENIED)
   - Интерцептор работает для всех `/r/*` endpoints

6. ✅ Восстановление пароля работает:
   - POST `/auth/forgot-password` генерирует и отправляет код на email
   - Код сохраняется в БД с хешированием
   - POST `/auth/reset-password` валидирует код и обновляет пароль
   - Код истекает через 15 минут
   - Код может быть использован только один раз
   - Rate limiting защищает от спама
   - Email отправляется корректно с кодом восстановления

7. ✅ Единый формат ошибок работает:
   - Все ошибки возвращаются в едином формате
   - traceId присутствует в error response
   - HTTP статусы корректны (4xx, 5xx)
   - Ошибки аутентификации имеют правильные exceptionName:
     - `TOKEN_EXPIRED` для истекшего access token
     - `REFRESH_TOKEN_EXPIRED` для истекшего refresh token
     - `INVALID_TOKEN` для невалидного токена
     - `INVALID_REFRESH_TOKEN` для невалидного refresh token
     - `UNAUTHORIZED` для общих ошибок авторизации

8. ✅ Rate limiting работает:
   - `/auth/login` защищен от брутфорса
   - `/auth/forgot-password` защищен от спама (максимум 3 запроса в час)
   - При превышении лимита возвращается ошибка

9. ✅ CORS и CSRF работают:
   - CORS настроен для admin-web
   - CSRF защита работает

10. ✅ traceId в логах:
   - traceId присутствует в логах через MDC
   - traceId корректно передается между запросами

### Критерии готовности:
- ✅ Все компоненты аутентификации созданы и работают
- ✅ JWT токены генерируются и валидируются корректно
- ✅ Refresh tokens работают и хранятся в БД
- ✅ Таблица `password_reset_codes` создана и работает
- ✅ Восстановление пароля работает (forgot-password и reset-password)
- ✅ Email отправляется корректно с кодом восстановления
- ✅ @PreAuthorize защищает endpoints по ролям
- ✅ Интерцептор проверяет доступ менеджеров к ресторанам
- ✅ Единый формат ошибок работает для всех endpoints
- ✅ traceId доступен в логах и error response
- ✅ Rate limiting, CORS, CSRF настроены и работают
- ✅ Все функциональные проверки пройдены успешно

**Шаг считается выполненным**, когда:
- Все endpoints аутентификации работают
- JWT токены работают корректно
- Роли и права доступа работают через @PreAuthorize и интерцептор
- Единый формат ошибок работает
- traceId доступен в логах и error response
- Все функциональные проверки пройдены успешно


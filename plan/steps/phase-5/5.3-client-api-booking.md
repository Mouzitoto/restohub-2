# Шаг 5.3: Бронирование

## Описание
Реализация процесса бронирования стола с предзаказом блюд через форму на сайте и подтверждение через WhatsApp бот.

## Процесс бронирования

1. Клиент на фронте выбирает стол и предзаказ блюд
2. Клиент нажимает кнопку "Забронировать"
3. Веб отправляет POST запрос на `/client-api/r/:id/booking` с данными:
   - Стол, дата, время, количество персон
   - "Свое имя" (опционально)
   - "На чье имя бронировать" (опционально)
   - Особые пожелания (опционально)
   - Список блюд для предзаказа (опционально)
4. Бэк создает бронирование в статусе DRAFT с `client_id = NULL`
5. Бэк создает позиции предзаказа в `booking_pre_orders` (если указаны блюда)
6. Бэк создает запись в `booking_history` (DRAFT)
7. Бэк возвращает фронту:
   - `booking_id` - ID созданного бронирования
   - `whatsappUrl` - ссылка на WhatsApp бот с `booking_id` и текстом сообщения
   - `message` - текст для WhatsApp сообщения
8. Фронт редиректит юзера на WhatsApp ссылку и вставляет в поле ввода текст
9. Юзер в WhatsApp жмет кнопку "Отправить"
10. WhatsApp бот получает сообщение, в тексте которого есть `booking_id`
11. WhatsApp бот получает номер телефона юзера через WhatsApp SDK
12. WhatsApp бот вызывает API `/admin-api/booking/:id/confirm` для подтверждения бронирования
13. API создает/обновляет клиента в таблице `clients`:
    - Если клиент существует - обновляет `first_name` (если указано новое имя)
    - Если клиент новый - создает запись с `phone` и `first_name`
14. API обновляет бронирование:
    - Устанавливает `client_id` (обязательное поле теперь заполнено)
    - Меняет статус с DRAFT на PENDING
15. API создает запись в `booking_history` (PENDING)
16. API уведомляет WhatsApp бота о новом бронировании
17. WhatsApp бот отправляет сообщение менеджеру ресторана с информацией о бронировании (на языке из `restaurants.manager_language_code`)
18. Менеджер подтверждает/отклоняет бронь через кнопку внутри WhatsApp чата с ботом
19. Менеджер может нажать кнопку "Связаться с клиентом" для открытия WhatsApp чата с клиентом

## Задачи

### 1. API для создания бронирования (клиентская форма)
- **POST** `/client-api/r/:id/booking`
- Тело запроса:
  - `table_id` - long (required) - ID стола
  - `date` - date (required, format: YYYY-MM-DD) - дата бронирования
  - `time` - time (required, format: HH:mm:ss) - время бронирования
  - `personCount` - integer (required, min: 1) - количество персон
  - `client_first_name` - string (optional, max 255) - "свое имя" клиента
  - `client_name` - string (optional, max 255) - "на чье имя бронировать"
  - `special_requests` - string (optional, TEXT, max 10000) - особые пожелания
  - `preOrderItems` - array (optional) - массив позиций предзаказа:
    - `menu_item_id` - long (required) - ID блюда
    - `quantity` - integer (required, min: 1) - количество
    - `special_requests` - string (optional, TEXT, max 10000) - особые пожелания к блюду

**Response 201 Created:**
```json
{
  "id": 1,
  "restaurantId": 1,
  "tableId": 5,
  "date": "2024-01-15",
  "time": "19:00:00",
  "personCount": 4,
  "clientName": "Петр Петров",
  "specialRequests": "У окна",
  "status": {
    "code": "DRAFT",
    "name": "Черновик"
  },
  "whatsappUrl": "https://wa.me/79991234567?text=BOOKING:1",
  "message": "BOOKING:1",
  "createdAt": "2024-01-01T09:00:00Z"
}
```

**Логика:**
1. Валидация всех полей согласно правилам
2. Проверка существования ресторана: `SELECT * FROM restaurants WHERE id = :id AND is_active = true`
3. Проверка активной подписки: `SELECT * FROM restaurant_subscriptions WHERE restaurant_id = :id AND is_active = true`
4. Проверка существования стола: `SELECT * FROM tables WHERE id = :tableId AND is_active = true`
5. Проверка принадлежности стола к ресторану: через JOIN `tables → rooms → floors → restaurants`
6. Проверка соответствия количества персон вместимости стола
7. Валидация формата даты и времени
8. Проверка, что дата/время не в прошлом
9. Валидация позиций предзаказа (если указаны):
   - Проверка существования всех блюд
   - Проверка доступности блюд (is_available = true)
   - Проверка принадлежности блюд к ресторану
10. Создание записи в таблице `bookings`:
    - `restaurant_id = :id`
    - `table_id = :tableId`
    - `client_id = NULL` (будет установлен после подтверждения через WhatsApp)
    - `client_name = :clientName` ("на чье имя бронировать")
    - `date = :date`
    - `time = :time`
    - `person_count = :personCount`
    - `special_requests = :specialRequests` (если указано)
    - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'DRAFT')`
    - `created_at = NOW()`
    - `updated_at = NOW()`
11. Создание позиций предзаказа в таблице `booking_pre_orders` (если указаны блюда):
    - Для каждой позиции:
      - `booking_id = <созданный_id>`
      - `menu_item_id = :menuItemId`
      - `quantity = :quantity`
      - `price = :price` (актуальная цена на момент заказа)
      - `total_price = :price * :quantity`
      - `special_requests = :specialRequests` (если указано для позиции)
      - `created_at = NOW()`
      - `updated_at = NOW()`
12. Создание записи в таблице `booking_history`:
    - `booking_id = <созданный_id>`
    - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'DRAFT')`
    - `changed_at = NOW()`
    - `changed_by = NULL` (создано клиентом)
    - `comment = NULL`
13. Генерация WhatsApp ссылки:
    - Формат сообщения: `BOOKING:<booking_id>`
    - Пример: `BOOKING:1`
    - URL encoding текста сообщения
    - Формирование ссылки: `https://wa.me/<номер_вацап_бота>?text=<закодированное_сообщение>`
    - Номер WhatsApp бота хранится в конфигурации системы
14. Возврат созданного бронирования с WhatsApp ссылкой

**Ошибки:**
- 400 Bad Request: невалидные данные, ресторан не найден или неактивен, стол не найден, количество персон превышает вместимость стола, дата/время в прошлом, блюдо не найдено или недоступно
- 404 Not Found: ресторан не найден, стол не найден, блюдо не найдено

### 2. API для подтверждения бронирования через WhatsApp бот
- **POST** `/admin-api/booking/:id/confirm` (публичный endpoint, вызывается WhatsApp ботом)
- Path параметры:
  - `id` - long (required) - ID бронирования
- Тело запроса:
  - `phone` - string (required) - номер телефона клиента (получен от WhatsApp SDK, формат: +7XXXXXXXXXX)
  - `client_first_name` - string (optional, max 255) - "свое имя" клиента
  - `whatsapp_message_id` - string (optional, max 255) - ID сообщения в WhatsApp

**Response 200 OK:**
```json
{
  "id": 1,
  "restaurantId": 1,
  "tableId": 5,
  "date": "2024-01-15",
  "time": "19:00:00",
  "personCount": 4,
  "clientId": 1,
  "clientName": "Петр Петров",
  "specialRequests": "У окна",
  "status": {
    "code": "PENDING",
    "name": "Ожидает подтверждения"
  },
  "whatsappNotificationSent": true,
  "createdAt": "2024-01-01T09:00:00Z"
}
```

**Логика:**
1. Поиск бронирования: `SELECT * FROM bookings WHERE id = :id AND booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'DRAFT')`
2. Валидация номера телефона (формат `+7XXXXXXXXXX` или `8XXXXXXXXXX`)
3. Нормализация номера телефона к формату `+7XXXXXXXXXX`
4. Работа с таблицей `clients`:
   - Поиск клиента: `SELECT * FROM clients WHERE phone = :phone`
   - Если клиент существует:
     - Обновить `first_name = :clientFirstName` (если указано новое имя)
     - Обновить `last_booking_date = NOW()`
     - Увеличить `total_bookings = total_bookings + 1`
     - Обновить `updated_at = NOW()`
     - Сохранить `client_id` для бронирования
   - Если клиент не существует:
     - Создать нового клиента:
       - `phone = :phone` (нормализованный)
       - `first_name = :clientFirstName` (если указано)
       - `first_booking_date = NOW()`
       - `last_booking_date = NOW()`
       - `total_bookings = 1`
       - `total_pre_orders = 0`
       - `created_at = NOW()`
       - `updated_at = NOW()`
     - Сохранить `client_id` для бронирования
5. Обновление бронирования:
   - `client_id = :clientId` (обязательное поле теперь заполнено)
   - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'PENDING')` (меняем статус с DRAFT на PENDING)
   - `whatsapp_message_id = :whatsappMessageId` (если указано)
   - `updated_at = NOW()`
6. Создание записи в таблице `booking_history`:
   - `booking_id = :id`
   - `booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'PENDING')`
   - `changed_at = NOW()`
   - `changed_by = NULL` (подтверждено клиентом через WhatsApp бот)
   - `comment = NULL`
7. Вызов WhatsApp бота для уведомления менеджера:
   - Получить список менеджеров ресторана: `SELECT u.* FROM users u JOIN users_2_restaurants u2r ON u.id = u2r.user_id WHERE u2r.restaurant_id = :restaurantId AND u.role_id = (SELECT id FROM roles WHERE code = 'MANAGER')`
   - Получить язык менеджера из `restaurants.manager_language_code`
   - Отправить уведомление каждому менеджеру через WhatsApp бот API (на номер телефона из `users.phone`)
   - В уведомлении: информация о бронировании, позиции предзаказа (если есть), номер телефона клиента, кнопки "Подтвердить", "Отказать" и "Связаться с клиентом"
8. Возврат обновленного бронирования

**Ошибки:**
- 400 Bad Request: невалидные данные, бронирование не найдено или уже подтверждено, неверный формат номера телефона
- 404 Not Found: бронирование не найдено
- 500 Internal Server Error: ошибка при вызове WhatsApp бота

### 3. Валидация данных

#### 3.1. Правила валидации для каждого поля

**table_id** (ID стола):
- Обязательное поле (`@NotNull`)
- Тип: LONG
- Валидатор: `@ValidTableId` - проверка существования, активности и принадлежности к ресторану

**date** (дата бронирования):
- Обязательное поле (`@NotNull`)
- Формат: YYYY-MM-DD (`@Pattern` или `@DateTimeFormat`)
- Не может быть в прошлом (`@Future` или кастомная проверка)

**time** (время бронирования):
- Обязательное поле (`@NotNull`)
- Формат: HH:mm:ss (`@Pattern` или `@TimeFormat`)

**personCount** (количество персон):
- Обязательное поле (`@NotNull`)
- Тип: INTEGER
- Минимальное значение: 1 (`@Min(1)`)
- Проверка соответствия вместимости стола (кастомная валидация)

**client_first_name** ("свое имя" клиента):
- Опциональное поле
- Максимальная длина: 255 символов (`@Size(max = 255)`)
- Не может быть пустой строкой (после trim)

**client_name** ("на чье имя бронировать"):
- Опциональное поле
- Максимальная длина: 255 символов (`@Size(max = 255)`)
- Не может быть пустой строкой (после trim)

**special_requests** (особые пожелания):
- Опциональное поле
- Тип: TEXT
- Максимальная длина: 10000 символов (`@Size(max = 10000)`)

**preOrderItems** (массив позиций предзаказа):
- Опциональное поле
- Каждая позиция должна содержать:
  - `menu_item_id` - обязательное поле, тип LONG
  - `quantity` - обязательное поле, тип INTEGER, минимальное значение: 1
  - `special_requests` - опциональное поле, тип TEXT, максимальная длина: 10000

**phone** (номер телефона клиента - для подтверждения):
- Обязательное поле (`@NotNull`)
- Формат: `+7XXXXXXXXXX` или `8XXXXXXXXXX` (10 цифр после +7 или 8)
- Нормализация к формату `+7XXXXXXXXXX` при сохранении
- Кастомный валидатор: `@Phone` (см. шаг 3.1)

#### 3.2. Кастомные валидаторы

**@ValidTableId** - проверка существования, активности и принадлежности стола к ресторану:
```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ValidTableIdValidator.class)
public @interface ValidTableId {
    String message() default "Table not found, inactive, or does not belong to restaurant";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```
- Проверка через JOIN `tables → rooms → floors → restaurants`
- Возвращает ошибку, если стол не найден, неактивен или не принадлежит ресторану

#### 3.3. Логика проверки существования связанных сущностей

**Проверка ресторана:**
1. Выполнить запрос: `SELECT * FROM restaurants WHERE id = :id AND is_active = true`
2. Если ресторан не найден или неактивен → вернуть ошибку 400

**Проверка активной подписки:**
1. Выполнить запрос: `SELECT * FROM restaurant_subscriptions WHERE restaurant_id = :id AND is_active = true`
2. Если подписка не найдена или неактивна → вернуть ошибку 400

**Проверка стола:**
1. Выполнить запрос: `SELECT t.*, f.restaurant_id FROM tables t JOIN rooms r ON t.room_id = r.id JOIN floors f ON r.floor_id = f.id WHERE t.id = :tableId AND t.is_active = true`
2. Если стол не найден или неактивен → вернуть ошибку 400
3. Если `f.restaurant_id != :id` → вернуть ошибку 400

**Проверка соответствия количества персон:**
1. Получить `capacity` стола из запроса выше
2. Если `personCount > capacity` → вернуть ошибку 400

**Проверка даты/времени:**
1. Проверить, что `date` не в прошлом (сравнить с текущей датой)
2. Если `date` сегодня, проверить, что `time` не в прошлом (сравнить с текущим временем)
3. Если дата/время в прошлом → вернуть ошибку 400

**Проверка блюд для предзаказа:**
1. Выполнить запрос: `SELECT * FROM menu_items WHERE id IN (:menuItemIds) AND is_active = true AND is_available = true`
2. Если какое-то блюдо не найдено или недоступно → вернуть ошибку 400
3. Проверка принадлежности к ресторану: `SELECT * FROM menu_items WHERE id IN (:menuItemIds) AND restaurant_id = :id`
4. Если какое-то блюдо не принадлежит ресторану → вернуть ошибку 400

**Проверка бронирования при подтверждении:**
1. Выполнить запрос: `SELECT * FROM bookings WHERE id = :id AND booking_status_id = (SELECT id FROM booking_statuses WHERE code = 'DRAFT')`
2. Если бронирование не найдено или уже подтверждено → вернуть ошибку 400

### 4. Генерация WhatsApp ссылки

#### 4.1. Формат сообщения для WhatsApp
- Формат: `BOOKING:<booking_id>`
- Пример: `BOOKING:1`
- Все значения URL-кодируются

#### 4.2. Формирование ссылки
- Формат ссылки: `https://wa.me/<номер_вацап_бота>?text=<закодированное_сообщение>`
- Номер WhatsApp бота хранится в конфигурации системы (международный формат, например: `79991234567`)
- URL encoding текста сообщения (encodeURIComponent)

### 5. Логика работы с клиентами

#### 5.1. Создание/обновление клиента при подтверждении
- При подтверждении бронирования WhatsApp бот передает номер телефона и имя клиента
- Если клиент существует:
  - Обновить `first_name` (если указано новое имя)
  - Обновить `last_booking_date = NOW()`
  - Увеличить `total_bookings = total_bookings + 1`
  - Обновить `updated_at = NOW()`
- Если клиент не существует:
  - Создать нового клиента:
    - `phone = :phone` (нормализованный)
    - `first_name = :clientFirstName` (если указано)
    - `first_booking_date = NOW()`
    - `last_booking_date = NOW()`
    - `total_bookings = 1`
    - `total_pre_orders = 0`
    - `created_at = NOW()`
    - `updated_at = NOW()`

### 6. Интеграция с Telegram ботом
- API для отправки уведомлений менеджерам:
  - Endpoint Telegram бота (настраивается через конфигурацию)
  - Формат уведомления: текст с информацией о бронировании + список позиций предзаказа (если есть) + inline кнопки
  - Кнопки: "Подтвердить" и "Отклонить" с callback данными (booking_id, manager_id)
- Обработка callback от Telegram бота:
  - Получение данных из callback
  - Вызов соответствующего endpoint для изменения статуса (см. шаг 3.7)

### 7. Обработка ошибок
- Валидационные ошибки (400)
- Ресторан не найден (404)
- Стол не найден (404)
- Некорректные данные (400)
- Неверный формат номера телефона (400)
- Количество персон превышает вместимость стола (400)
- Дата/время в прошлом (400)
- Бронирование не найдено или уже подтверждено (400)
- Блюдо не найдено или недоступно (400)
- Ошибка при вызове WhatsApp бота (500)

## Результаты выполнения шага

По итогу выполнения этого шага должны быть созданы следующие артефакты и выполнены следующие проверки:

### Созданные компоненты:
1. ✅ Booking Controller:
   - `POST /client-api/r/:id/booking` endpoint (создание бронирования в статусе DRAFT)
   - `POST /admin-api/booking/:id/confirm` endpoint (подтверждение через WhatsApp бот)

2. ✅ Booking Service:
   - Метод для создания бронирования (в статусе DRAFT, с client_id = NULL)
   - Метод для создания позиций предзаказа
   - Метод для подтверждения бронирования (установка client_id, смена статуса на PENDING)
   - Метод для создания/обновления клиента
   - Метод для генерации WhatsApp ссылки
   - Валидация данных
   - Интеграция с WhatsApp ботом

3. ✅ Валидация:
   - Валидация обязательных полей
   - Проверка существования ресторана и стола
   - Проверка принадлежности стола к ресторану
   - Проверка соответствия количества персон вместимости стола
   - Проверка даты/времени (не в прошлом)
   - Валидация позиций предзаказа
   - Валидация номера телефона

### Функциональные проверки:
1. ✅ Создание бронирования работает:
   - Бронирование создается в статусе DRAFT с `client_id = NULL`
   - Позиции предзаказа создаются корректно
   - Запись создается в истории изменений (DRAFT)
   - WhatsApp ссылка генерируется с booking_id

2. ✅ Подтверждение бронирования работает:
   - Бронирование обновляется с обязательным `client_id`
   - Статус меняется с DRAFT на PENDING
   - Клиент создается/обновляется корректно
   - Запись создается в истории изменений (PENDING)
   - WhatsApp бот получает уведомление и отправляет его менеджеру

3. ✅ Валидация работает:
   - Обязательные поля проверяются
   - Ресторан и стол проверяются на существование и активность
   - Количество персон проверяется на соответствие вместимости стола
   - Дата/время проверяются (не в прошлом)
   - Позиции предзаказа проверяются на существование и доступность
   - Номер телефона валидируется и нормализуется

4. ✅ Работа с клиентами работает:
   - Новый клиент создается корректно
   - Существующий клиент обновляется корректно
   - Статистика клиента обновляется

5. ✅ Генерация WhatsApp ссылки работает:
   - Ссылка содержит booking_id
   - Сообщение правильно URL-кодируется
   - Ссылка открывает WhatsApp с предзаполненным текстом

### Критерии готовности:
- ✅ Все endpoints работают
- ✅ Валидация данных работает
- ✅ Клиент создается/обновляется корректно
- ✅ Бронирование создается в статусе DRAFT, затем обновляется на PENDING с `client_id`
- ✅ Позиции предзаказа создаются корректно
- ✅ WhatsApp ссылка генерируется корректно (с booking_id)
- ✅ Запись создается в истории изменений
- ✅ Интеграция с WhatsApp ботом работает
- ✅ Все функциональные проверки пройдены успешно

**Шаг считается выполненным**, когда все endpoints работают и все функциональные проверки пройдены успешно.

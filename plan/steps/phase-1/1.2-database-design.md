# Шаг 1.2: Проектирование базы данных

## Описание
Проектирование схемы базы данных PostgreSQL для всей системы: определение сущностей, связей, миграций. Использование Spring Data JPA для работы с БД и Liquibase для миграций на native SQL.

## Технологии
- **PostgreSQL** - последняя стабильная версия
- **Spring Data JPA** - ORM для работы с БД из Spring Boot приложений (только чтение Entity, не генерация схемы)
- **Liquibase** - миграции на native SQL (выбранный инструмент)

## Задачи

### 1. Определение основных сущностей (предварительный список)

#### Основные сущности:
- **roles** - роли пользователей системы (ADMIN, MANAGER)
- **users** - пользователи системы (администраторы, менеджеры, **без клиентов** - клиенты не регистрируются на первом этапе)
- **users_2_restaurants** - маппинг пользователей к ресторанам (many-to-many)
- **images** - единая таблица для всех изображений в системе (логотипы, фоны, фотографии блюд, столов и т.д.)
- **clients** - клиенты ресторанов (номера телефонов, история бронирований для аналитики)
- **restaurants** - рестораны (включая персональную настройку страницы: лого, фон, темы)
- **subscription_types** - типы подписок (STANDARD, PREMIUM и т.д.) с описаниями
- **restaurant_subscriptions** - подписки ресторанов (связь с subscription_types через foreign key)
- **menu_categories** - категории блюд
- **menu_items** - блюда меню
- **floors** - этажи ресторана
- **rooms** - помещения на этажах
- **tables** - столы (включая характеристики: окно, кондиционер, курение и т.д.)
- **booking_statuses** - статусы бронирований и предзаказов (PENDING, APPROVED, REJECTED, CANCELLED_BY_CLIENT, CANCELLED_BY_MANAGER)
- **bookings** - бронирования (только для статистики, не для управления доступностью)
- **booking_history** - история изменений статусов бронирований
- **booking_pre_orders** - предзаказы блюд к бронированию
- **promotion_types** - типы промо-событий (акция, тематический вечер, новинка и т.д.)
- **promotions** - промо-события ресторанов (акции, тематические вечера, новинки) с связью с promotion_types через foreign key

### 2. Принципы проектирования
- **Мягкое удаление (soft delete)**: использование полей `is_active` (BOOLEAN) и `deleted_at` (TIMESTAMP)
  - Причина: сохранение статистики и отчетов, возможность восстановления данных
  - Сущности с мягким удалением: roles, images, restaurants, subscription_types, promotion_types, menu_items, tables, menu_categories, floors, rooms, promotions, booking_statuses
  - Поля:
    - `is_active` - BOOLEAN, NOT NULL, DEFAULT TRUE (основной флаг активности)
    - `deleted_at` - TIMESTAMP, NULL (дата удаления, для истории)
  - При удалении:
    - Устанавливать `is_active = FALSE`
    - Устанавливать `deleted_at = CURRENT_TIMESTAMP`
  - При восстановлении:
    - Устанавливать `is_active = TRUE`
    - Очищать `deleted_at = NULL`
  - **Важно**: В репозиториях не использовать автоматическую фильтрацию по `is_active`
  - В каждом SQL запросе **явно** указывать условие `WHERE is_active = TRUE` (или `FALSE` для запросов,  требующих удаленные элементы)
  - Это позволяет делать запросы с удаленными элементами когда необходимо (статистика, восстановление)
- **Аудит полей**: 
  - `created_at` - дата создания (TIMESTAMP, NOT NULL, DEFAULT NOW())
  - `updated_at` - дата обновления (TIMESTAMP, NOT NULL, DEFAULT NOW())
  - `is_active` - флаг активности (BOOLEAN, NOT NULL, DEFAULT TRUE)
  - `deleted_at` - дата удаления (TIMESTAMP, NULL)

### 3. Разработка схемы БД
**Примечание**: Детальная схема БД разработана и описана в разделе 3.1. Дополнительные изменения могут быть внесены при детализации фаз по компонентам системы (фазы 3-6).

#### Подход к разработке схемы:
- **Начинаем с БД**: Сначала создаем схему в SQL (миграции Liquibase), затем создаем Entity классы в Spring Data JPA
- **Не обновляем схему через Spring Data**: Изменения схемы только через миграции Liquibase
- Entity классы отражают существующую схему, а не генерируют её

#### Предварительные требования к схеме:
- Определение всех полей для каждой таблицы
- Определение типов данных (с учетом PostgreSQL):
  - BLOB для изображений: тип `bytea` для полей `image_data` и `preview_data` в таблице `images`
  - TIMESTAMP для дат
  - BOOLEAN для флагов
  - VARCHAR/TEXT для строк
  - DECIMAL для денежных сумм и координат
  - INTEGER для числовых значений
- Определение NOT NULL constraints
- Определение DEFAULT значений
- Настройка foreign keys с правильными constraints
- Настройка cascade удалений где необходимо
- Уникальные индексы (UNIQUE constraints)

### 3.1. Детальная структура всех таблиц

#### Таблица `roles` (роли пользователей):
- `id` - BIGSERIAL PRIMARY KEY
- `code` - VARCHAR(50) UNIQUE NOT NULL (ADMIN, MANAGER)
- `name` - VARCHAR(255) NOT NULL (название роли: "Администратор", "Менеджер")
- `description` - TEXT (описание роли, опционально)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

#### Таблица `users` (пользователи системы):
- `id` - BIGSERIAL PRIMARY KEY
- `email` - VARCHAR(255) UNIQUE NOT NULL
- `password_hash` - VARCHAR(255) NOT NULL (хэш пароля)
- `role_id` - BIGINT NOT NULL REFERENCES roles(id)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

#### Таблица `users_2_restaurants` (маппинг пользователей к ресторанам):
- `id` - BIGSERIAL PRIMARY KEY
- `user_id` - BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE
- `restaurant_id` - BIGINT NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- UNIQUE(user_id, restaurant_id)

#### Таблица `images` (единая таблица для всех изображений):
- `id` - BIGSERIAL PRIMARY KEY
- `image_data` - BYTEA NOT NULL (основное изображение)
- `preview_data` - BYTEA NOT NULL (превью изображения)
- `mime_type` - VARCHAR(100) NOT NULL (image/jpeg, image/png и т.д.)
- `file_size` - BIGINT NOT NULL (размер файла в байтах)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

#### Таблица `restaurants` (рестораны):
- `id` - BIGSERIAL PRIMARY KEY
- `name` - VARCHAR(255) NOT NULL
- `address` - VARCHAR(500) (адрес ресторана)
- `phone` - VARCHAR(50) (телефон ресторана)
- `whatsapp` - VARCHAR(50) (номер WhatsApp)
- `instagram` - VARCHAR(255) (ссылка на Instagram)
- `latitude` - DECIMAL(10, 8) (координата широты)
- `longitude` - DECIMAL(11, 8) (координата долготы)
- `description` - TEXT (описание ресторана)
- `working_hours` - TEXT (рабочие часы в текстовом формате)
- `manager_language_code` - VARCHAR(10) NOT NULL DEFAULT 'ru' (код языка для общения с менеджером ресторана: 'ru', 'en', 'kz' и т.д.)
- `logo_image_id` - BIGINT REFERENCES images(id) (логотип ресторана, опционально)
- `bg_image_id` - BIGINT REFERENCES images(id) (фон страницы ресторана, опционально)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

#### Таблица `subscription_types` (типы подписок):
- `id` - BIGSERIAL PRIMARY KEY
- `code` - VARCHAR(50) UNIQUE NOT NULL (STANDARD, PREMIUM и т.д.)
- `name` - VARCHAR(255) NOT NULL (название типа подписки)
- `description` - TEXT (описание типа подписки, опционально)
- `price` - DECIMAL(10, 2) (цена подписки, опционально)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

**Примечание**: Длительность подписки указывается в `restaurant_subscriptions` при активации подписки (поля `start_date` и `end_date`).

#### Таблица `restaurant_subscriptions` (подписки ресторанов):
- `id` - BIGSERIAL PRIMARY KEY
- `restaurant_id` - BIGINT NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE
- `subscription_type_id` - BIGINT NOT NULL REFERENCES subscription_types(id)
- `start_date` - DATE NOT NULL (дата начала подписки)
- `end_date` - DATE NOT NULL (дата окончания подписки)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `description` - TEXT (причина изменения активности, опционально)
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()

#### Таблица `menu_categories` (категории блюд):
- `id` - BIGSERIAL PRIMARY KEY
- `name` - VARCHAR(255) NOT NULL UNIQUE
- `description` - TEXT (описание категории, опционально)
- `display_order` - INTEGER NOT NULL DEFAULT 0 (порядок отображения)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

#### Таблица `menu_items` (блюда меню):
- `id` - BIGSERIAL PRIMARY KEY
- `restaurant_id` - BIGINT NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE
- `menu_category_id` - BIGINT NOT NULL REFERENCES menu_categories(id)
- `name` - VARCHAR(255) NOT NULL
- `description` - TEXT (описание блюда, опционально)
- `ingredients` - TEXT (список ингредиентов, опционально)
- `price` - DECIMAL(10, 2) NOT NULL (базовая цена)
- `discount_percent` - INTEGER DEFAULT 0 (процент скидки, 0-100)
- `spiciness_level` - INTEGER DEFAULT 0 (уровень остроты, 0-5)
- `has_sugar` - BOOLEAN NOT NULL DEFAULT FALSE (содержит ли сахар)
- `image_id` - BIGINT REFERENCES images(id) (фотография блюда, опционально)
- `display_order` - INTEGER NOT NULL DEFAULT 0 (порядок отображения)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

#### Таблица `floors` (этажи ресторана):
- `id` - BIGSERIAL PRIMARY KEY
- `restaurant_id` - BIGINT NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE
- `floor_number` - VARCHAR(50) NOT NULL (номер этажа, примеры: "1", "Крыша", "Подвал", "Веранда", "1Б")
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL
- UNIQUE(restaurant_id, floor_number)

#### Таблица `rooms` (помещения на этажах):
- `id` - BIGSERIAL PRIMARY KEY
- `floor_id` - BIGINT NOT NULL REFERENCES floors(id) ON DELETE CASCADE
- `name` - VARCHAR(255) NOT NULL
- `description` - TEXT (описание помещения, опционально)
- `is_smoking` - BOOLEAN NOT NULL DEFAULT FALSE (курение разрешено в зале)
- `is_outdoor` - BOOLEAN NOT NULL DEFAULT FALSE (зал на открытом воздухе: веранда, крыша, на улице)
- `image_id` - BIGINT REFERENCES images(id) (план помещения с расположением столов, опционально, превью генерируется автоматически)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

#### Таблица `tables` (столы):
- `id` - BIGSERIAL PRIMARY KEY
- `room_id` - BIGINT NOT NULL REFERENCES rooms(id) ON DELETE CASCADE
- `table_number` - VARCHAR(50) NOT NULL (номер стола)
- `capacity` - INTEGER NOT NULL (количество мест)
- `description` - TEXT (описание стола, опционально)
- `image_id` - BIGINT REFERENCES images(id) (фотография стола, опционально)
- `deposit_amount` - TEXT (минимальная сумма депозита при бронировании стола, опционально)
- `deposit_note` - TEXT (примечание о депозите, например "только на напитки", опционально)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL
- UNIQUE(room_id, table_number)

#### Таблица `promotion_types` (типы промо-событий):
- `id` - BIGSERIAL PRIMARY KEY
- `code` - VARCHAR(50) UNIQUE NOT NULL (PROMOTION, THEMATIC_EVENT, NEW_ITEM и т.д.)
- `name` - VARCHAR(255) NOT NULL (название типа: "Акция", "Тематический вечер", "Новинка")
- `description` - TEXT (описание типа, опционально)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

#### Таблица `promotions` (промо-события ресторанов):
- `id` - BIGSERIAL PRIMARY KEY
- `restaurant_id` - BIGINT NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE
- `promotion_type_id` - BIGINT NOT NULL REFERENCES promotion_types(id)
- `title` - VARCHAR(255) NOT NULL (заголовок промо-события)
- `description` - TEXT (описание промо-события, опционально)
- `start_date` - DATE NOT NULL (дата начала)
- `end_date` - DATE NOT NULL (дата окончания)
- `image_id` - BIGINT REFERENCES images(id) (изображение промо-события, опционально)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `deleted_at` - TIMESTAMP NULL

#### Таблица `clients` (клиенты ресторанов):
- `id` - BIGSERIAL PRIMARY KEY
- `phone` - VARCHAR(50) UNIQUE NOT NULL (номер телефона в международном формате)
- `first_name` - VARCHAR(255) (имя клиента, опционально)
- `first_booking_date` - TIMESTAMP (дата первого бронирования)
- `last_booking_date` - TIMESTAMP (дата последнего бронирования)
- `total_bookings` - INTEGER NOT NULL DEFAULT 0 (количество бронирований для аналитики)
- `total_pre_orders` - INTEGER NOT NULL DEFAULT 0 (количество предзаказов для аналитики)
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()

**Примечание**: Таблица clients создается сразу как часть схемы БД. Запись о клиенте создается автоматически при первом обращении через WhatsApp бот. Номер телефона и имя клиента ("свое имя") получаются через WhatsApp бот при создании бронирования. Если клиент уже существует, обновляется `first_name` (если указано новое имя) и `last_booking_date`.

#### Таблица `booking_statuses` (статусы бронирований и предзаказов):
- `id` - BIGSERIAL PRIMARY KEY
- `code` - VARCHAR(50) NOT NULL UNIQUE (код статуса: PENDING, APPROVED, REJECTED, CANCELLED_BY_CLIENT, CANCELLED_BY_MANAGER)
- `name` - VARCHAR(255) NOT NULL (название статуса для отображения)
- `display_order` - INTEGER NOT NULL DEFAULT 0 (порядок отображения)
- `is_active` - BOOLEAN NOT NULL DEFAULT TRUE
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()

**Начальные данные:**
- DRAFT - "Черновик" (бронирование создано, но номер телефона клиента еще не подтвержден и информация об этом бронировании не отправлена менеджеру ресторана)
- PENDING - "Ожидает подтверждения"
- APPROVED - "Одобрено"
- REJECTED - "Отклонено"
- CANCELLED_BY_CLIENT - "Отменено клиентом"
- CANCELLED_BY_MANAGER - "Отменено менеджером"

**Примечание**: Таблицу booking_statuses может редактировать только ADMIN через админку. Для этого предусмотрены API endpoints в admin-api.

#### Таблица `bookings` (бронирования):
- `id` - BIGSERIAL PRIMARY KEY
- `restaurant_id` - BIGINT NOT NULL REFERENCES restaurants(id) ON DELETE CASCADE
- `table_id` - BIGINT NOT NULL REFERENCES tables(id)
- `client_id` - BIGINT REFERENCES clients(id) (NULL для статуса DRAFT, обязательное поле для остальных статусов)
- `client_name` - VARCHAR(255) (на чье имя забронировали, может отличаться от имени клиента)
- `date` - DATE NOT NULL (дата бронирования)
- `time` - TIME NOT NULL (время бронирования)
- `person_count` - INTEGER NOT NULL (количество персон)
- `special_requests` - TEXT (особые пожелания, опционально)
- `booking_status_id` - BIGINT NOT NULL REFERENCES booking_statuses(id)
- `whatsapp_message_id` - VARCHAR(255) (ID сообщения в WhatsApp, опционально)
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()

**Примечание**: Бронирование создается в два этапа: 1) Клиент на фронте выбирает стол и предзаказ блюд, нажимает "Забронировать" - веб отправляет запрос в бэк, бэк создает бронирование в статусе DRAFT с `client_id = NULL`, создает позиции предзаказа в `booking_pre_orders`, возвращает фронту WhatsApp ссылку с `booking_id` и текстом сообщения. 2) Клиент отправляет сообщение в WhatsApp бот - WhatsApp бот получает номер телефона через WhatsApp SDK и `booking_id` из сообщения, создает/обновляет клиента в таблице `clients`, обновляет бронирование (устанавливает `client_id` и меняет статус на PENDING). `client_name` содержит "на чье имя бронировать" (может отличаться от `clients.first_name`). При создании бронирования `booking_status_id` устанавливается на статус с code = 'DRAFT', после подтверждения через WhatsApp - на 'PENDING'. Каждое изменение статуса бронирования записывается в таблицу `booking_history`.

#### Таблица `booking_history` (история изменений статусов бронирований):
- `id` - BIGSERIAL PRIMARY KEY
- `booking_id` - BIGINT NOT NULL REFERENCES bookings(id) ON DELETE CASCADE
- `booking_status_id` - BIGINT NOT NULL REFERENCES booking_statuses(id) (статус, на который изменилось бронирование)
- `changed_at` - TIMESTAMP NOT NULL DEFAULT NOW() (когда произошло изменение)
- `changed_by` - BIGINT REFERENCES users(id) (кто изменил статус, NULL если изменил клиент или бот)
- `comment` - TEXT (комментарий к изменению, опционально)
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()

**Примечание**: При каждом изменении статуса бронирования создается новая запись в этой таблице. Это позволяет отслеживать полную историю изменений (например: PENDING → APPROVED → CANCELLED).

#### Таблица `booking_pre_orders` (предзаказы блюд к бронированию):
- `id` - BIGSERIAL PRIMARY KEY
- `booking_id` - BIGINT NOT NULL REFERENCES bookings(id) ON DELETE CASCADE (обязательное, предзаказ только к бронированию)
- `menu_item_id` - BIGINT NOT NULL REFERENCES menu_items(id) (ID блюда)
- `quantity` - INTEGER NOT NULL (количество этого блюда)
- `price` - DECIMAL(10, 2) NOT NULL (цена за единицу на момент заказа)
- `total_price` - DECIMAL(10, 2) NOT NULL (общая стоимость позиции: price * quantity)
- `special_requests` - TEXT (особые пожелания к конкретному блюду, опционально)
- `whatsapp_message_id` - VARCHAR(255) (ID сообщения в WhatsApp, опционально)
- `created_at` - TIMESTAMP NOT NULL DEFAULT NOW()
- `updated_at` - TIMESTAMP NOT NULL DEFAULT NOW()

**Примечание**: Предзаказ создается вместе с бронированием на фронте. Клиент выбирает стол и предзаказ блюд, нажимает "Забронировать" - бэк создает бронирование в статусе DRAFT и позиции предзаказа в этой таблице. Предзаказ можно создать только к существующему бронированию. Каждая позиция предзаказа (блюдо) создается отдельной записью в этой таблице. Если предзаказали 5 блюд, то в таблице будет 5 строк с одним `booking_id`. Предзаказ носит лишь информативный характер для ресторана и не изменяет свои статусы - статус берется из связанного бронирования (`bookings.booking_status_id`).



### 4. Индексы
**Примечание**: Индексы будут создаваться и оптимизироваться в конце каждой фазы после реализации функционала и анализа запросов к БД.

- Индексы будут добавляться по мере необходимости
- Анализ запросов будет проводиться после реализации каждой фазы
- Оптимизация производительности запросов будет частью процесса разработки

### 5. Подготовка миграций (Liquibase)
- Выбор инструмента: **Liquibase** (на native SQL)
- Структура для миграций в `database/`:
  ```
  database/
  ├── liquibase/
  │   ├── changelog/
  │   │   └── db.changelog-master.xml
  │   └── changesets/
  │       └── V1__initial_schema.sql
  ```
- Настроить Spring Boot для автоматического применения миграций при запуске приложений
- Первичная миграция будет создана после разработки детальной схемы БД
- Миграции применяются автоматически при старте Spring Boot приложений (client-api и admin-api)

### 6. Seed данные
- Создать seed скрипты для тестирования и разработки:
  - Тестовые администраторы и менеджеры
  - Тестовые рестораны
  - Примеры меню и блюд
  - Примеры столов и карт расположения
- Seed данные будут подготовлены **после проектирования схемы БД**
- **Отдельный SQL скрипт** `database/seed/seed-data.sql`
- Использовать `IF NOT EXISTS` проверки для предотвращения дублирования данных при повторных запусках
- Запуск через docker-compose отдельным сервисом (одноразовый запуск)
- Пример структуры:
  ```sql
  -- Проверка существования перед вставкой
  DO $$
  BEGIN
    IF NOT EXISTS (SELECT 1 FROM users WHERE email = 'admin@restohub.com') THEN
      INSERT INTO users (...) VALUES (...);
    END IF;
  END $$;
  ```

### 7. Документирование схемы
- Создать ER-диаграмму (визуализация всех сущностей и связей)
- Документировать все relationships (one-to-many, many-to-many)
- Документировать cardinality связей
- Сохранить диаграмму в репозитории (формат: PNG, SVG, или инструмент типа dbdiagram.io)

### 8. Настройка Spring Data JPA
- **Создание Entity классов для всех сущностей** (после создания схемы БД через миграции)
- Entity классы отражают существующую схему, не генерируют её
- Настройка связей между Entity (@OneToMany, @ManyToOne, @ManyToMany)
- Настройка репозиториев (интерфейсы Repository)
- **Важно**: Репозитории не используют автоматическую фильтрацию по `is_active`
- В методах репозиториев явно указывать условия для `is_active` когда необходимо
- Базовая конфигурация JPA в Spring Boot

### 9. Роли пользователей
- Хранение ролей в БД (таблица `users` с полем `role` или отдельная таблица ролей)
- Роли на первом этапе:
  - `ADMIN` - администратор системы
  - `MANAGER` - менеджер ресторана
- OAuth2.0 для аутентификации в admin-api
- Использование `@PreAuthorize(hasRole("ADMIN"))` и `@PreAuthorize(hasRole("MANAGER"))` для защиты endpoints
- Детали реализации ролей будут уточнены в фазе 2 (Аутентификация и авторизация)

### 10. Резервное копирование
- На первом этапе автоматическое резервное копирование не требуется
- Будет реализовано в фазе 9 (Деплой)

### 11. Индексы
**Примечание**: Индексы будут создаваться и оптимизироваться в конце каждой фазы после реализации функционала и анализа запросов к БД.

- Индексы будут добавляться по мере необходимости через миграции Liquibase
- Анализ запросов будет проводиться после реализации каждой фазы
- Оптимизация производительности запросов будет частью процесса разработки
- Итоговая оптимизация индексов будет выполнена в фазе 8 (Оптимизация)

## Результаты выполнения шага

По итогу выполнения этого шага должны быть созданы следующие артефакты и выполнены следующие проверки:

### Созданные документы и схемы:
1. ✅ Детальная схема базы данных:
   - Все 19 таблиц описаны с полным списком колонок
   - Для каждой колонки указан тип данных (BIGSERIAL, VARCHAR, DECIMAL, BOOLEAN, TIMESTAMP, BYTEA и т.д.)
   - Указаны все ограничения (NOT NULL, UNIQUE, DEFAULT)
   - Указаны все внешние ключи (REFERENCES) с правильными constraints
   - Указаны составные UNIQUE индексы где необходимо

2. ✅ Документация принципов проектирования:
   - Описана стратегия мягкого удаления (soft delete)
   - Описаны аудит поля для всех таблиц
   - Указаны сущности с мягким удалением
   - Описаны правила работы с `is_active` в репозиториях

3. ✅ Описание всех таблиц:
   - `roles` - роли пользователей
   - `users` - пользователи системы
   - `users_2_restaurants` - маппинг пользователей к ресторанам
   - `images` - единая таблица для всех изображений
   - `restaurants` - рестораны
   - `subscription_types` - типы подписок
   - `restaurant_subscriptions` - подписки ресторанов
   - `menu_categories` - категории блюд
   - `menu_items` - блюда меню
   - `floors` - этажи ресторана
   - `rooms` - помещения на этажах
   - `tables` - столы
   - `clients` - клиенты ресторанов
   - `bookings` - бронирования
   - `booking_pre_orders` - предзаказы блюд к бронированию
   - `promotion_types` - типы промо-событий
   - `promotions` - промо-события ресторанов

### Созданные SQL миграции:
1. ✅ Первичная миграция Liquibase:
   - `database/liquibase/changesets/V1__initial_schema.sql` создан
   - Миграция содержит CREATE TABLE для всех 19 таблиц
   - Все внешние ключи настроены корректно
   - Все UNIQUE constraints настроены
   - Все DEFAULT значения установлены
   - Все NOT NULL constraints установлены

2. ✅ Changelog файл:
   - `database/liquibase/changelog/db.changelog-master.xml` настроен
   - Changelog ссылается на V1__initial_schema.sql
   - Настроена правильная структура для будущих миграций

### Функциональные проверки:
1. ✅ Миграция применяется успешно:
   - При запуске Spring Boot приложений миграция применяется автоматически
   - Все таблицы создаются в базе данных
   - Все ограничения работают корректно
   - Нет ошибок при применении миграции

2. ✅ Структура БД соответствует схеме:
   - Все 19 таблиц существуют в базе данных
   - Все колонки созданы с правильными типами
   - Все внешние ключи работают
   - Все UNIQUE constraints работают
   - Все DEFAULT значения работают

3. ✅ Проверка связей:
   - Связи между таблицами работают корректно
   - ON DELETE CASCADE работает где необходимо
   - Внешние ключи не позволяют создавать некорректные связи

### Критерии готовности:
- ✅ Схема базы данных полностью описана в документе
- ✅ Все таблицы имеют детальное описание колонок и типов данных
- ✅ Первичная миграция Liquibase создана и готова к применению
- ✅ Миграция успешно применяется при старте приложений
- ✅ Все таблицы создаются в базе данных без ошибок
- ✅ Структура БД соответствует описанной схеме
- ✅ Документация содержит все необходимые примечания и пояснения

**Шаг считается выполненным**, когда:
- Схема БД полностью описана в документе
- Первичная миграция создана и протестирована
- Миграция успешно применяется при старте приложений
- Все таблицы создаются корректно в базе данных

